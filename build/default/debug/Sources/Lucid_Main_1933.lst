CCS PCM C Compiler, Version 5.050, 5967               14-Apr-16 01:30

               Filename:   F:\Chast_2\PROEKTI\Lucid\PIC16F1933\Lucid1933.X\build\default\debug\Sources\Lucid_Main_1933.lst

               ROM used:   3107 words (76%)
                           Largest free fragment is 986
               RAM used:   98 (40%) at main() level
                           149 (61%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 15

*
0000:  NOP
0001:  MOVLP  08
0002:  GOTO   223
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  BTFSS  0B.3
0010:  GOTO   013
0011:  BTFSC  0B.0
0012:  GOTO   027
0013:  BTFSS  0B.5
0014:  GOTO   017
0015:  BTFSC  0B.2
0016:  GOTO   029
0017:  CLRF   05
0018:  MOVLW  91
0019:  MOVWF  04
001A:  BTFSS  00.5
001B:  GOTO   01E
001C:  BTFSC  11.5
001D:  GOTO   02B
001E:  MOVF   20,W
001F:  MOVWF  77
0020:  MOVF   21,W
0021:  MOVWF  78
0022:  MOVF   22,W
0023:  MOVWF  79
0024:  MOVF   23,W
0025:  MOVWF  7A
0026:  RETFIE
0027:  MOVLP  00
0028:  GOTO   1D5
0029:  MOVLP  00
002A:  GOTO   1A0
002B:  MOVLP  00
002C:  GOTO   033
....................  
.................... #include <16F1933.h> 
.................... //////////// Standard Header file for the PIC16F1933 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1933 
*
0198:  BSF    0A.0
0199:  BCF    0A.1
019A:  BCF    0A.2
019B:  ADDWF  02,F
019C:  GOTO   040
019D:  GOTO   04A
019E:  GOTO   055
019F:  GOTO   068
*
03EA:  MOVLB  01
03EB:  MOVF   40,W
03EC:  CLRF   78
03ED:  SUBWF  3F,W
03EE:  BTFSC  03.0
03EF:  GOTO   3F3
03F0:  MOVF   3F,W
03F1:  MOVWF  77
03F2:  GOTO   3FF
03F3:  CLRF   77
03F4:  MOVLW  08
03F5:  MOVWF  41
03F6:  RLF    3F,F
03F7:  RLF    77,F
03F8:  MOVF   40,W
03F9:  SUBWF  77,W
03FA:  BTFSC  03.0
03FB:  MOVWF  77
03FC:  RLF    78,F
03FD:  DECFSZ 41,F
03FE:  GOTO   3F6
03FF:  MOVLB  00
0400:  RETURN
*
0481:  CLRF   77
0482:  CLRF   78
0483:  MOVLB  01
0484:  MOVF   3C,W
0485:  BCF    03.0
0486:  BTFSC  3D.0
0487:  ADDWF  77,F
0488:  RRF    77,F
0489:  RRF    78,F
048A:  BTFSC  3D.1
048B:  ADDWF  77,F
048C:  RRF    77,F
048D:  RRF    78,F
048E:  BTFSC  3D.2
048F:  ADDWF  77,F
0490:  RRF    77,F
0491:  RRF    78,F
0492:  BTFSC  3D.3
0493:  ADDWF  77,F
0494:  RRF    77,F
0495:  RRF    78,F
0496:  BTFSC  3D.4
0497:  ADDWF  77,F
0498:  RRF    77,F
0499:  RRF    78,F
049A:  BTFSC  3D.5
049B:  ADDWF  77,F
049C:  RRF    77,F
049D:  RRF    78,F
049E:  BTFSC  3D.6
049F:  ADDWF  77,F
04A0:  RRF    77,F
04A1:  RRF    78,F
04A2:  BTFSC  3D.7
04A3:  ADDWF  77,F
04A4:  RRF    77,F
04A5:  RRF    78,F
04A6:  MOVLB  00
04A7:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #include "Lucid_Main_1933.h" 
.................... #ifndef LUCID_MAIN_H 
.................... #define	LUCID_MAIN_H 
....................  
.................... #define cTrue (1 == 1) 
.................... #define cFalse (1 == 0) 
.................... #define uint8 unsigned int8 
.................... #define uint16 unsigned int16 
....................  
.................... #include "SFR.h" 
.................... #ifndef SFRh 
.................... #define	SFRh 
....................  
.................... //PIC16F1933 
....................  
.................... #Byte    INDF0    =    0x000 
.................... #Byte    INDF1    =    0x001 
.................... #Byte    PCL    =    0x002 
.................... #Byte    STATUS    =    0x003 
.................... #Byte    FSR0L    =    0x004 
.................... #Byte    FSR0H    =    0x005 
.................... #Byte    FSR1L    =    0x006 
.................... #Byte    FSR1H    =    0x007 
.................... #Byte    BSR    =    0x008 
.................... #Byte    WREG    =    0x009 
.................... #Byte    INTCON    =    0x00B 
.................... #Byte    PORTA    =    0x00C 
.................... #Byte    PORTB    =    0x00D 
.................... #Byte    PORTC    =    0x00E 
.................... #Byte    PORTE    =    0x010 
.................... #Byte    PIR1    =    0x011 
.................... #Byte    PIR2    =    0x012 
.................... #Byte    PIR3    =    0x013 
.................... #Byte    TMR0    =    0x015 
.................... #Byte    TMR1L    =    0x016 
.................... #Byte    TMR1H    =    0x017 
.................... #Byte    T1CON    =    0x018 
.................... #Byte    T1GCON    =    0x019 
.................... #Byte    TMR2    =    0x01A 
.................... #Byte    PR2    =    0x01B 
.................... #Byte    T2CON    =    0x01C 
.................... #Byte    CPSCON0    =    0x01E 
.................... #Byte    CPSCON1    =    0x01F 
.................... #Byte    TRISA    =    0x08C 
.................... #Byte    TRISB    =    0x08D 
.................... #Byte    TRISC    =    0x08E 
.................... #Byte    TRISE    =    0x090 
.................... #Byte    PIE1    =    0x091 
.................... #Byte    PIE2    =    0x092 
.................... #Byte    PIE3    =    0x093 
.................... #Byte    OPTION_REG    =    0x095 
.................... #Byte    PCON    =    0x096 
.................... #Byte    WDTCON    =    0x097 
.................... #Byte    OSCTUNE    =    0x098 
.................... #Byte    OSCCON    =    0x099 
.................... #Byte    OSCSTAT    =    0x09A 
.................... #Byte    ADRESL    =    0x09B 
.................... #Byte    ADRESH    =    0x09C 
.................... #Byte    ADCON0    =    0x09D 
.................... #Byte    ADCON1    =    0x09E 
.................... #Byte    LATB    =    0x10D 
.................... #Byte    LATC    =    0x10E 
.................... #Byte    CM1CON0    =    0x111 
.................... #Byte    CM1CON1    =    0x112 
.................... #Byte    CM2CON0    =    0x113 
.................... #Byte    CM2CON1    =    0x114 
.................... #Byte    CMOUT    =    0x115 
.................... #Byte    BORCON    =    0x116 
.................... #Byte    FVRCON    =    0x117 
.................... #Byte    DACCON0    =    0x118 
.................... #Byte    DACCON1    =    0x119 
.................... #Byte    SRCON0    =    0x11A 
.................... #Byte    SRCON1    =    0x11B 
.................... #Byte    APFCON    =    0x11D 
.................... #Byte    ANSELB    =    0x18D 
.................... #Byte    EEADRL    =    0x191 
.................... #Byte    EEADRH    =    0x192 
.................... #Byte    EEDATL    =    0x193 
.................... #Byte    EEDATH    =    0x194 
.................... #Byte    EECON1    =    0x195 
.................... #Byte    EECON2    =    0x196 
.................... #Byte    RCREG    =    0x199 
.................... #Byte    TXREG    =    0x19A 
.................... #Byte    SPBRGL    =    0x19B 
.................... #Byte    SPBRGH    =    0x19C 
.................... #Byte    RCSTA    =    0x19D 
.................... #Byte    TXSTA    =    0x19E 
.................... #Byte    BAUDCTR    =    0x19F 
.................... #Byte    WPUE    =    0x210 
.................... #Byte    SSPBUF    =    0x211 
.................... #Byte    SSPADD    =    0x212 
.................... #Byte    SSPMSK    =    0x213 
.................... #Byte    SSPSTAT    =    0x214 
.................... #Byte    SSPCON1    =    0x215 
.................... #Byte    SSPCON2    =    0x216 
.................... #Byte    SSPCON3    =    0x217 
.................... #Byte    CCPR1    =    0x292 
.................... #Byte    CCP1CON    =    0x293 
.................... #Byte    PWM1CON    =    0x294 
.................... #Byte    CCP1AS    =    0x295 
.................... #Byte    PSTR1CON    =    0x296 
.................... #Byte    CCPR2L    =    0x298 
.................... #Byte    CCPR2H    =    0x299 
.................... #Byte    CCP2CON    =    0x29A 
.................... #Byte    PWM2CON    =    0x29B 
.................... #Byte    CCP2AS    =    0x29C 
.................... #Byte    PSTR2CON    =    0x29D 
.................... #Byte    CCPTMRS0    =    0x29E 
.................... #Byte    CCPTMRS1    =    0x29F 
.................... #Byte    CCPR3    =    0x312 
.................... #Byte    CCP3CON    =    0x313 
.................... #Byte    PWM3CON    =    0x314 
.................... #Byte    CCP3AS    =    0x315 
.................... #Byte    PSTR3CON    =    0x316 
.................... #Byte    CCPR4L    =    0x318 
.................... #Byte    CCPR4H    =    0x319 
.................... #Byte    CCP4CON    =    0x31A 
.................... #Byte    CCPR5L    =    0x31C 
.................... #Byte    CCPR5H    =    0x31D 
.................... #Byte    CCP5CON    =    0x31E 
.................... #Byte    IOCBP    =    0x394 
.................... #Byte    IOCBN    =    0x395 
.................... #Byte    IOCBF    =    0x396 
.................... #Byte	 WPUB 	=   0x20D 
....................  
.................... #Byte    INDF1    =    0x401 
.................... // 
.................... #Byte    PCLATH    =    0x40A 
.................... #Byte    TMR4    =    0x415 
.................... #Byte    PR4    =    0x416 
.................... #Byte    T4CON    =    0x417 
.................... #Byte    TMR6    =    0x41C 
.................... #Byte    PR6    =    0x41D 
.................... #Byte    T6CON    =    0x41E 
....................  
.................... #bit    HFIOFS      =   OSCSTAT.0 
.................... #bit    CCP3SEL     =   APFCON.6 
....................  
.................... #Bit    PORTB0      =   PORTB.0 
.................... #Bit    PORTB1      =   PORTB.1 
.................... #Bit    PORTB2      =   PORTB.2 
.................... #Bit    PORTB3      =   PORTB.3 
.................... #Bit    PORTB5      =   PORTB.5 
.................... #Bit    PORTB6      =   PORTB.6 
.................... #Bit    PORTB7      =   PORTB.7 
....................  
.................... #Bit    PORTC0      =   PORTC.0 
.................... #Bit    PORTC1      =   PORTC.1 
.................... #Bit    PORTC2      =   PORTC.2 
.................... #Bit    PORTC3      =   PORTC.3 
.................... #Bit    PORTC4      =   PORTC.4 
.................... #Bit    PORTC5      =   PORTC.5 
.................... #Bit    PORTC6      =   PORTC.6 
.................... #Bit    PORTC7      =   PORTC.7 
....................  
.................... #Bit    PORTA0      =   PORTA.0 
.................... #Bit    PORTA1      =   PORTA.1 
.................... #Bit    PORTA2      =   PORTA.2 
.................... #Bit    PORTA3      =   PORTA.3 
.................... #Bit    PORTA4      =   PORTA.4 
.................... #Bit    PORTA5      =   PORTA.5 
.................... #Bit    PORTA6      =   PORTA.6 
.................... #Bit    PORTA7      =   PORTA.7 
....................  
.................... #Bit    TRISA0      =   TRISA.0 
.................... #Bit    TRISA1      =   TRISA.1 
.................... #Bit    TRISA2      =   TRISA.2 
.................... #Bit    TRISA3      =   TRISA.3 
.................... #Bit    TRISA4      =   TRISA.4 
.................... #Bit    TRISA5      =   TRISA.5 
.................... #Bit    TRISA6      =   TRISA.6 
.................... #Bit    TRISA7      =   TRISA.7 
....................  
.................... #Bit    TRISB0      =   TRISB.0 
.................... #Bit    TRISB1      =   TRISB.1 
.................... #Bit    TRISB2      =   TRISB.2 
.................... #Bit    TRISB3      =   TRISB.3 
.................... #Bit    TRISB4      =   TRISB.4 
.................... #Bit    TRISB5      =   TRISB.5 
.................... #Bit    TRISB6      =   TRISB.6 
.................... #Bit    TRISB7      =   TRISB.7 
....................  
.................... #Bit    GIE         =   INTCON.7 
.................... #Bit    PEIE        =   INTCON.6 
.................... #Bit    TMR0IE      =   INTCON.5 
.................... #Bit    IOCIE       =   INTCON.3//Interrupt-on-Change Enable bit 
.................... #Bit    TMR1IE      =   PIE1.0 
.................... #Bit    RCIE        =   PIE1.5 
.................... #Bit    CCP4IE      =   PIE3.5 
.................... #Bit    TMR2IF      =   PIR1.1 
.................... #Bit    RCIF        =   PIR1.5 
....................  
.................... #endif SFRh 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #device ADC=16 //ICD=TRUE 
.................... #device ICD=TRUE 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOCLKOUT                 //I/O function on OSC2 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOVCAP                   //VCAP pin disabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES BORV19                   //Brownout reset at 1.9V 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #use delay(internal=16000000) 
*
01F6:  MOVLW  20
01F7:  MOVWF  05
01F8:  MOVLW  62
01F9:  MOVWF  04
01FA:  MOVF   00,W
01FB:  BTFSC  03.2
01FC:  GOTO   20B
01FD:  MOVLW  05
01FE:  MOVWF  78
01FF:  CLRF   77
0200:  DECFSZ 77,F
0201:  GOTO   200
0202:  DECFSZ 78,F
0203:  GOTO   1FF
0204:  MOVLW  2E
0205:  MOVWF  77
0206:  DECFSZ 77,F
0207:  GOTO   206
0208:  GOTO   209
0209:  DECFSZ 00,F
020A:  GOTO   1FD
020B:  RETURN
....................  
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
*
002D:  BTFSS  11.4
002E:  GOTO   02D
002F:  MOVLB  03
0030:  MOVWF  1A
0031:  MOVLB  00
0032:  RETURN
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3,force_hw) 
*
0210:  MOVLB  04
0211:  BCF    15.7
0212:  MOVLB  00
0213:  BCF    11.3
0214:  MOVLB  01
0215:  MOVF   4C,W
0216:  MOVLB  04
0217:  MOVWF  11
0218:  MOVLW  02
0219:  BTFSC  15.7
021A:  GOTO   222
021B:  MOVLB  00
021C:  BTFSS  11.3
021D:  GOTO   21C
021E:  MOVLW  00
021F:  MOVLB  04
0220:  BTFSC  16.6
0221:  MOVLW  01
0222:  MOVWF  78
0223:  MOVLB  00
0224:  RETURN
*
0252:  MOVLB  04
0253:  BCF    15.6
0254:  BSF    16.3
0255:  BTFSC  16.3
0256:  GOTO   255
0257:  BTFSC  77.0
0258:  BCF    16.5
0259:  BTFSS  77.0
025A:  BSF    16.5
025B:  BSF    16.4
025C:  BTFSC  16.4
025D:  GOTO   25C
025E:  MOVF   11,W
025F:  MOVWF  78
0260:  MOVLB  00
0261:  RETURN
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Main_Init(void); 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #endif	/* LUCID_MAIN_H */ 
....................  
....................  
....................  
.................... #include "RS232RX.c" 
.................... #include <Effects.h> 
....................  
.................... #ifndef EFFECT 
.................... #define	EFFECT 
....................  
.................... #define	MaxLED 5 
.................... int8 u8IncMaskFlag = 0; 
....................  
.................... int8 u8IncPWMFlag = 0b00111111; 
....................  
.................... int8 u8IncLEDFlag = 1; 
....................  
.................... //int1 u1Increment1L = 1; 
.................... //int1 u1Increment2L = 1; 
.................... //int1 u1Increment3L = 1; 
.................... //int1 u1Increment4L = 1; 
.................... //int1 u1Increment5L = 1; 
.................... //int1 u1Increment6L = 1; 
....................  
.................... uint8 u8Moove[6] = { 0, 0, 0, 0, 0, 0 }; 
.................... //uint8 u8Moove[6] = { 0, 0, 0, 0, 0, 0 }; 
....................  
.................... uint8 u8Duty[6] = { 0, 0, 0, 0, 0, 0 }; 
....................  
.................... //int1 u1StartFlag1L = 0; 
.................... int1 u1StartFlagGlowAltL = 0; 
.................... //     int1 u1StartFlag2L = 1; 
.................... //     int1 u1StartFlag3L = 1; 
....................  
....................  
.................... unsigned int16 u16EffectCounterL = 0; 
....................  
.................... void Sweep_Left(void); 
.................... void Glow_Alt(void); 
.................... void Effects_Task(void); 
.................... void Rotate_Left_Incrementation_Mask(void); 
.................... void Set_Xth_Bit(uint8 *u8ByteP, uint8 u8XthBitP); 
.................... void Disable_Port(void); 
.................... void NextLed(uint8 u8CurLEDP); 
.................... #endif	/* EFFECT*/ 
....................  
.................... #include <DS1307.h> 
....................  
....................  
....................  
.................... #ifndef DS 
.................... #define	DS 
....................  
.................... #include "ClockCalculationTransformation.c" 
....................  
.................... #include "ClockCalculationTransformation.h" 
....................  
.................... #ifndef ClockCalculationTransformation 
.................... #define ClockCalculationTransformation 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //CCT - Clock Calculation Transformation 
.................... #define TenSecCCT      4 
.................... #define SecCCT         5 
.................... #define TenMinCCT      2 
.................... #define MinCCT         3 
.................... #define TenHourCCT     0 
.................... #define HourCCT        1 
....................  
.................... #define MasHour        0 
.................... #define MasMin         1 
.................... #define MasSec         2 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void TestClockInputs(uint8 *pDataP); 
.................... #ifndef DS 
.................... void DS_Print_Clock(uint8 *pDataP); 
.................... #endif 
.................... void DS_Print_Clock_Mas(uint8 *pDataP, uint8 u8NewLineP); 
.................... void DigitsToInt (uint8 *u8InputP, uint8 *u8OutputP); 
.................... void IntToDigits (uint8 *u8InputP, uint8 *u8OutputP); 
.................... void AddTimeToClock(uint8 *u8ClockP, uint8 u8AddedTimeP); 
.................... void DigitsTest (void); 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #endif //#define ClockCalculationTransformation 
....................  
.................... #include "DS13XX.h" 
.................... #ifndef DS13XX 
.................... #define	DS13XX 
....................  
.................... void DS_Print_Clock_3by(uint8 *pDataP, uint8 u8NewLineP); 
.................... void DS_Read_Clock_3by(uint8 *pDataP); 
.................... void DS_String_To_Massiv_Clock_3by(uint8 * u8ClockSetP, char * cMsgClockP); 
.................... void DS_Init_Clock_3by(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DecodeInitPrintClock_3by(char * cMsgClockP); 
....................  
.................... void SetSnoozeDelay_3by(char * cMsgClockP); 
.................... void SetInitialDelay_3by(char * cMsgClockP); 
....................  
.................... void AddTimeToAlarm_3by(void); 
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void TestClockInputs(uint8 *pDataP) 
.................... { 
....................      
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef DS 
.................... void DS_Print_Clock(uint8 *pDataP) 
.................... { 
....................     putc(10); 
....................     putc(13); 
....................     putc(pDataP[TenHour]+48); 
....................     putc(pDataP[Hour]+48); 
....................     putc(58); 
....................     putc(pDataP[TenMin]+48); 
....................     putc(pDataP[Min]+48); 
....................     putc(58); 
....................     putc(pDataP[TenSec]+48); 
....................     putc(pDataP[Sec]+48); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //void DS_Print_Clock_Mas(uint8 *pDataP) 
.................... //{ 
.................... //    printf("\n\r%d:%d:%d",pDataP[MasHour] 
.................... //                         ,pDataP[MasMin] 
.................... //                         ,pDataP[MasSec]); 
.................... //} 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Print_Clock_Mas(uint8 *pDataP, uint8 u8NewLineP) 
.................... { 
....................     DS_Print_Clock_3by(pDataP, u8NewLineP); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*Transform from u8InputP{2,3,5,9,5,9} to u8OutputP{23,59,59};*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DigitsToInt (uint8 *u8InputP, uint8 *u8OutputP) 
.................... { 
....................     u8OutputP[MasHour] = u8InputP[TenHourCCT] * 10; 
....................     u8OutputP[MasHour] += u8InputP[HourCCT] ; 
....................      
....................     u8OutputP[MasMin] = u8InputP[TenMinCCT] * 10; 
....................     u8OutputP[MasMin] += u8InputP[MinCCT] ; 
....................      
....................     u8OutputP[MasSec] = u8InputP[TenSecCCT] * 10; 
....................     u8OutputP[MasSec] += u8InputP[SecCCT] ; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //Transform from {23,59,59} to {2,3,5,9,5,9}; 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void IntToDigits (uint8 *u8InputP, uint8 *u8OutputP) 
.................... { 
....................     u8OutputP[TenHourCCT] = u8InputP[MasHour] / 10; 
....................     u8OutputP[HourCCT]    = u8InputP[MasHour] % 10; 
....................      
....................     u8OutputP[TenMinCCT] = u8InputP[MasMin] / 10; 
....................     u8OutputP[MinCCT]    = u8InputP[MasMin] % 10; 
....................      
....................     u8OutputP[TenSecCCT] = u8InputP[MasSec] / 10; 
....................     u8OutputP[SecCCT]    = u8InputP[MasSec] % 10; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /* u8ClockP     is in format {23,59,59}  
....................    u8AddedTimeP is in format {23,59,59} */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void AddTimeToClock(uint8 *u8ClockP, uint8 *u8AddedTimeP) 
*
06AA:  CLRF   42
06AB:  MOVLW  02
06AC:  MOVWF  43
.................... { 
....................     uint8 u8ClockTempL[3] = {0,0,0}; 
*
06A7:  CLRF   3F
06A8:  CLRF   40
06A9:  CLRF   41
....................     uint8 u8CarryL = 0; 
....................     uint8 u8ForCounterL = 2; 
....................      
....................     for( u8ForCounterL = 2; (0 <= u8ForCounterL && 3 > u8ForCounterL); u8ForCounterL-- ) 
*
06AD:  MOVWF  43
06AE:  MOVF   43,W
06AF:  SUBLW  02
06B0:  BTFSS  03.0
06B1:  GOTO   744
....................     { 
....................         u8ClockTempL[u8ForCounterL] = u8ClockP[u8ForCounterL] + u8AddedTimeP[u8ForCounterL] + u8CarryL; 
06B2:  MOVLW  6F
06B3:  ADDWF  43,W
06B4:  MOVWF  78
06B5:  MOVLW  20
06B6:  MOVWF  7A
06B7:  BTFSC  03.0
06B8:  INCF   7A,F
06B9:  MOVF   78,W
06BA:  MOVWF  46
06BB:  MOVF   7A,W
06BC:  MOVWF  47
06BD:  MOVF   43,W
06BE:  ADDWF  3B,W
06BF:  MOVWF  04
06C0:  MOVLW  00
06C1:  ADDWFC 3C,W
06C2:  MOVWF  05
06C3:  MOVF   00,W
06C4:  MOVWF  48
06C5:  MOVF   43,W
06C6:  ADDWF  3D,W
06C7:  MOVWF  04
06C8:  MOVLW  00
06C9:  ADDWFC 3E,W
06CA:  MOVWF  05
06CB:  MOVF   00,W
06CC:  ADDWF  48,W
06CD:  ADDWF  42,W
06CE:  MOVWF  48
06CF:  MOVF   47,W
06D0:  MOVWF  05
06D1:  MOVF   46,W
06D2:  MOVWF  04
06D3:  MOVF   48,W
06D4:  MOVWF  00
....................         if(0 != u8ForCounterL) 
06D5:  MOVF   43,F
06D6:  BTFSC  03.2
06D7:  GOTO   703
....................         { 
....................             if( 60 <= u8ClockTempL[u8ForCounterL] )  
06D8:  MOVLW  6F
06D9:  ADDWF  43,W
06DA:  MOVWF  04
06DB:  MOVLW  20
06DC:  MOVWF  05
06DD:  BTFSC  03.0
06DE:  INCF   05,F
06DF:  MOVF   00,W
06E0:  SUBLW  3B
06E1:  BTFSC  03.0
06E2:  GOTO   701
....................             { 
....................                 u8ClockTempL[u8ForCounterL] = u8ClockTempL[u8ForCounterL] - 60; 
06E3:  MOVLW  6F
06E4:  ADDWF  43,W
06E5:  MOVWF  78
06E6:  MOVLW  20
06E7:  MOVWF  7A
06E8:  BTFSC  03.0
06E9:  INCF   7A,F
06EA:  MOVF   78,W
06EB:  MOVWF  46
06EC:  MOVF   7A,W
06ED:  MOVWF  47
06EE:  MOVLW  6F
06EF:  ADDWF  43,W
06F0:  MOVWF  04
06F1:  MOVLW  20
06F2:  MOVWF  05
06F3:  BTFSC  03.0
06F4:  INCF   05,F
06F5:  MOVLW  3C
06F6:  SUBWF  00,W
06F7:  MOVWF  48
06F8:  MOVF   47,W
06F9:  MOVWF  05
06FA:  MOVF   46,W
06FB:  MOVWF  04
06FC:  MOVF   48,W
06FD:  MOVWF  00
....................                 u8CarryL = 1; 
06FE:  MOVLW  01
06FF:  MOVWF  42
....................             } 
0700:  GOTO   702
....................             else 
....................             { 
....................                 u8CarryL = 0; 
0701:  CLRF   42
....................             } 
....................         } 
0702:  GOTO   729
....................         else 
....................         { 
....................             if( 24 <= u8ClockTempL[u8ForCounterL] )  
0703:  MOVLW  6F
0704:  ADDWF  43,W
0705:  MOVWF  04
0706:  MOVLW  20
0707:  MOVWF  05
0708:  BTFSC  03.0
0709:  INCF   05,F
070A:  MOVF   00,W
070B:  SUBLW  17
070C:  BTFSC  03.0
070D:  GOTO   729
....................             { 
....................                 u8ClockTempL[u8ForCounterL] = u8ClockTempL[u8ForCounterL] - 24; 
070E:  MOVLW  6F
070F:  ADDWF  43,W
0710:  MOVWF  78
0711:  MOVLW  20
0712:  MOVWF  7A
0713:  BTFSC  03.0
0714:  INCF   7A,F
0715:  MOVF   78,W
0716:  MOVWF  46
0717:  MOVF   7A,W
0718:  MOVWF  47
0719:  MOVLW  6F
071A:  ADDWF  43,W
071B:  MOVWF  04
071C:  MOVLW  20
071D:  MOVWF  05
071E:  BTFSC  03.0
071F:  INCF   05,F
0720:  MOVLW  18
0721:  SUBWF  00,W
0722:  MOVWF  48
0723:  MOVF   47,W
0724:  MOVWF  05
0725:  MOVF   46,W
0726:  MOVWF  04
0727:  MOVF   48,W
0728:  MOVWF  00
....................             } 
....................         } 
....................         u8ClockP[u8ForCounterL] = u8ClockTempL[u8ForCounterL]; 
0729:  MOVF   43,W
072A:  ADDWF  3B,W
072B:  MOVWF  78
072C:  MOVLW  00
072D:  ADDWFC 3C,W
072E:  MOVWF  7A
072F:  MOVF   78,W
0730:  MOVWF  46
0731:  MOVF   7A,W
0732:  MOVWF  47
0733:  MOVLW  6F
0734:  ADDWF  43,W
0735:  MOVWF  04
0736:  MOVLW  20
0737:  MOVWF  05
0738:  BTFSC  03.0
0739:  INCF   05,F
073A:  MOVF   00,W
073B:  MOVWF  48
073C:  MOVF   47,W
073D:  MOVWF  05
073E:  MOVF   46,W
073F:  MOVWF  04
0740:  MOVF   48,W
0741:  MOVWF  00
0742:  DECF   43,F
0743:  GOTO   6AE
....................     } 
....................      
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DigitsTest (void) 
.................... { 
.................... //    uint8 u8Alarm[6]= {2,3,5,9,5,9}; 
....................     uint8 u8Alarm2[3]= {23,58,49}; 
....................     uint8 u8Alarm1[3]= {0,1,11};//{23,59,59}; 
....................     uint8 u8ForCounterL = 0; 
....................  
....................          
.................... //    { 
.................... //        DS_Print_Clock(u8Alarm); 
.................... //        DS_Print_Clock_Mas(u8Alarm1); 
.................... // 
.................... //        DigitsToInt(u8Alarm,u8Alarm1); 
.................... // 
.................... //        DS_Print_Clock_Mas(u8Alarm1); 
.................... // 
.................... //        IntToDigits(u8Alarm1,u8Alarm); 
.................... //    } 
....................     for( u8ForCounterL = 0; (59 >= u8ForCounterL ); u8ForCounterL++ ) 
....................     { 
....................         u8Alarm1[2] = u8ForCounterL; 
....................          
....................         DS_Print_Clock_Mas(u8Alarm1,1); 
....................         AddTimeToClock(u8Alarm2,u8Alarm1); 
....................  
....................         DS_Print_Clock_Mas(u8Alarm2,1); 
....................     } 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //============================================================================== 
.................... // PRIVATE MACROS 
.................... //============================================================================== 
.................... #define     DS3231_WriteX    0xD0 
.................... #define     DS3231_ReadX     0xD1 
....................  
.................... /*          DaynamicFlags       */ 
....................  
.................... #define     SetSnoozeDelayFlagMask      0x0001    //0b00000000 00000001 
.................... #define     SetInitialDelayFlagMask     0x0002    //0b00000000 00000010 
.................... #define     EffectIncrementFlagMask     0x0004    //0b00000000 00000100 
.................... #define     AddSnoozeDelayFlagMask      0x0008    //0b00000000 00001000 
.................... #define     SetAlarmFlagMask            0x0010    //0b00000000 00010000 
.................... #define     SetClockFlagMask            0x0020    //0b00000000 00100000 
.................... #define     OneSecondTaskFlagMask       0x0040    //0b00000000 01000000 
.................... #define     ReadeClockFlagMask          0x0080    //0b00000000 10000000 
.................... //u16ByteFlags2 
.................... #define     SleepDelayFlagMask          0x0001    //0b00000001 00000000 
....................  
.................... /*          StaticFlags       */ 
.................... #define     DebugPrintFlagMask          0x01    //0b00000001 
.................... #define     SleepFlagMask               0x02    //0b00000010 
.................... //TBD 
.................... //#define     u1StartFlagGlowAltL         0x04    //0b00000100 
....................  
.................... #define     DebugPrintClock     0x01 
....................  
.................... #Bit    DS_Power_Pin_TRIS   =   TRISC.5 
.................... #Bit    DS_Power_Pin        =   PORTC.5 
....................  
.................... void ds1307_write_test(unsigned char rtcreg, unsigned int8 rtc_data); 
.................... uint8 DS_Write_Test(unsigned char rtcreg, unsigned int8 rtc_data); 
....................  
.................... void min_inc(void); 
.................... void hour_inc(void); 
....................  
.................... void DS_Task(void); 
....................  
.................... void DS_Init(void); 
.................... void DS_Init_Clock(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_Data(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_OutClock(void); 
....................  
.................... void DS_Read_Clock(uint8 *pDataP); 
.................... void DS_Read_Data(uint8 *pDataP); 
....................  
.................... void DS_Print_Clock(uint8 *pDataP); 
.................... void DS_Print_Data(uint8 *pDataP); 
....................  
.................... void DS_Write(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
.................... void DS_Read(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... void DS_String_To_Massiv_Clock(uint8 * u8ClockSetP, char * cMsgClock); 
.................... void DS_String_To_Massiv_Data(uint8 * u8DateSetP, char * cMsgClock); 
....................  
.................... void SetSnoozeDelay(char * cMsgClockP); 
.................... void SetInitialDelay(char * cMsgClockP); 
....................  
.................... void DecodeClock(char * cMsgClock); 
.................... void DecodeData(char * cMsgClock); 
....................  
.................... uint8 DS_Reade_Pointer(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... uint8 Comppare_Time(uint8 *pDataP, uint8 *pAlarmP); 
.................... //uint8 Check_Sequences(uint8 *pDataP); 
.................... void Menage_Alarma(uint8 *pDataP); 
.................... void SetAlarm(void); 
.................... void AddTimeToAlarm(void); 
....................  
.................... //unsigned int8 rtensec; 
.................... //unsigned int8 rsec; 
.................... //unsigned int8 rtenmin; 
.................... //unsigned int8 rmin; 
.................... //unsigned int8 rtenhour; 
.................... //unsigned int8 rhour; 
.................... //unsigned int8 rday; 
.................... //unsigned int8 rtendate; 
.................... //unsigned int8 rdate; 
.................... //unsigned int8 rmonth; 
.................... //unsigned int8 rtenmonth; 
.................... //unsigned int8 rtenyear; 
.................... //unsigned int8 ryear; 
....................  
.................... unsigned int16 u16TaskTimeCounterL = 0; 
....................  
.................... unsigned int8 u8Alarm[6] = {5,9,5,9,0,0}; 
....................  
.................... unsigned int8 u8InitialDelay[6] = {0,0,3,0,0,4}; 
....................  
.................... unsigned int8 u8SnoozeDelay[6] = {5,9,5,9,2,3}; 
....................  
....................  
.................... //unsigned int8 u8ReadeClockFlag = 0; 
.................... //unsigned int8 u8SetDataFlag = 0; 
.................... //unsigned int8 u8DebugPrintFlag = 0; 
....................  
.................... //unsigned int8 u8SetNapDelayFlag = 0; 
....................  
.................... unsigned int16 u16ByteFlags = 0; 
.................... unsigned int16 u16ByteFlags2 = 0; 
.................... unsigned int8 u8StaicByteFlags = (SleepFlagMask || DebugPrintFlagMask); 
....................  
.................... #define TenSec      0 
.................... #define Sec         1 
.................... #define TenMin      2 
.................... #define Min         3 
.................... #define TenHour     4 
.................... #define Hour        5 
....................  
.................... #define AlarmTenSec      0 
.................... #define AlarmSec         1 
.................... #define AlarmTenMin      2 
.................... #define AlarmMin         3 
.................... #define AlarmTenHour     4 
.................... #define AlarmHour        5 
....................  
.................... #define Day         6 
....................  
.................... #define TenDate     0 
.................... #define Date        1 
.................... #define Month       2 
.................... #define TenMonth    3 
.................... #define TenYear     4 
.................... #define Year        5 
....................  
.................... //TBD 0b - 0x 
.................... #define Sec_Mask             0b00001111 
.................... #define TenSec_Mask          0b01110000 
.................... #define Min_Mask             0b00001111 
.................... #define TenMin_Mask          0b01110000 
.................... #define Hour_Mask            0b00001111 
.................... #define TenHour_Mask         0b00110000 
....................  
.................... #define Day_Mask             0b00000111 
.................... #define Date_Mask            0b00001111 
.................... #define TenDate_Mask         0b00110000 
.................... #define Month_Mask           0b00001111 
.................... #define TenMonth_Mask        0b00010000 
.................... #define Year_Mask            0b00001111 
.................... #define TenYear_Mask         0b11110000 
....................  
.................... #define Monday      1 
.................... #define Tuesday     2 
.................... #define Wednesday   3 
.................... #define Thursday    4 
.................... #define Friday      5 
.................... #define Saturday    6 
.................... #define Sunday      7 
....................  
.................... #endif	/* DS*/ 
....................  
.................... #include <PWMandTime.h> 
.................... //#ifndef #define PORTA0  
.................... //    #Bit    PORTA0      =   PORTA.0 
.................... //    #Bit    PORTA1      =   PORTA.1 
.................... //    #Bit    PORTA2      =   PORTA.2 
.................... //    #Bit    PORTA3      =   PORTA.3 
.................... //    #Bit    PORTA4      =   PORTA.4 
.................... //    #Bit    PORTA5      =   PORTA.5 
.................... //    #Bit    PORTA6      =   PORTA.6 
.................... //    #Bit    PORTA7      =   PORTA.7 
.................... //#endif 
.................... // 
.................... //#ifndef PORTC0 
.................... //    #Bit    PORTC0      =   PORTC.0 
.................... //    #Bit    PORTC1      =   PORTC.1 
.................... //    #Bit    PORTC2      =   PORTC.2 
.................... //    #Bit    PORTC3      =   PORTC.3 
.................... //    #Bit    PORTC4      =   PORTC.4 
.................... //    #Bit    PORTC5      =   PORTC.5 
.................... //    #Bit    PORTC6      =   PORTC.6 
.................... //    #Bit    PORTC7      =   PORTC.7 
.................... //#endif 
....................  
.................... #ifndef PWMandTimeFile 
.................... #define PWMandTimeFile 
....................  
.................... #define RTCInterruptPIN		0x01 
.................... #define UARTInterruptPIN	0x02 
....................  
.................... #define Right (0)   //pin_B 
.................... #define Left  (1)   //pin_B 
....................  
.................... #define PWM1    (0) 
.................... #define PWM2    (1) 
.................... #define PWM3    (2) 
....................  
.................... #define R_PWM1    PORTA3 
.................... #define R_PWM2    PORTA1 
.................... #define R_PWM3    PORTA2 
....................  
.................... #define L_PWM1    PORTA7 
.................... #define L_PWM2    PORTA6 
.................... #define L_PWM3    PORTA5 
....................  
.................... #define R_PWM1TRIS    TRISA1//ok 
.................... #define R_PWM2TRIS    TRISA2 
.................... #define R_PWM3TRIS    TRISA3 
....................  
.................... #define L_PWM1TRIS    TRISA5 
.................... #define L_PWM2TRIS    TRISA7 
.................... #define L_PWM3TRIS    TRISA6 
....................  
.................... void SetAllPWM( unsigned int16 u16PWM1P, 
....................                 unsigned int16 u16PWM2P, 
....................                 unsigned int16 u16PWM3P); 
....................  
.................... void Timer0_Init(void); 
.................... void Timer2_Init(void); 
....................  
.................... void PWM_Init(void); 
....................  
.................... void StartWakeUpFromUART(void); 
.................... void StopWakeUpFromUART(void); 
....................  
.................... unsigned int8 PWMDC[2][3] = {{ 0, 0, 0 },{ 0, 0, 0 }}; 
.................... unsigned int8 u8PWMCounter = 0; 
....................  
.................... #endif //#define PWMandTimeFile 
....................  
....................  
.................... #define MsgClockLengh 28 
....................  
.................... void DecodeClockData(char * cMsgClock); 
.................... void DC1307_String_To_Massiv_Clock(void); 
.................... void DecodeClock(char * cMsgClock); 
.................... void DecodeData(char * cMsgClock); 
.................... uint8 SurchForDelimiter(char * cMsgClock); 
....................  
.................... volatile char cMsgClock[MsgClockLengh]; 
....................  
.................... unsigned int8 u8StateMashine = 0; 
.................... unsigned int8 u8MsgCount = 0; 
....................  
.................... //#013#010kotarak#013#010 
.................... //#013#01013:04:00#013#010 
.................... //#013#01018\07\15#013#010 
.................... #INT_RDA 
.................... void  RDA_isr(void) 
.................... { 
....................     char c; 
....................     c = fgetc(); 
*
0033:  BTFSS  11.5
0034:  GOTO   033
0035:  MOVLB  03
0036:  MOVF   19,W
0037:  MOVLB  01
0038:  MOVWF  52
.................... //    fputc(c); 
....................    switch(u8StateMashine) 
0039:  MOVF   71,W
003A:  ADDLW  FC
003B:  BTFSC  03.0
003C:  GOTO   194
003D:  ADDLW  04
003E:  MOVLB  00
003F:  GOTO   198
....................    { 
....................        case 0: 
....................            if(c == 13) 
0040:  MOVLB  01
0041:  MOVF   52,W
0042:  SUBLW  0D
0043:  BTFSS  03.2
0044:  GOTO   048
....................            { 
....................                 u8StateMashine = 1; 
0045:  MOVLW  01
0046:  MOVWF  71
....................            } 
0047:  GOTO   049
....................            else 
....................            { 
....................                 u8StateMashine = 0; 
0048:  CLRF   71
....................            } 
....................            break; 
0049:  GOTO   194
....................  
....................        case 1: 
....................            if(c == 10) 
004A:  MOVLB  01
004B:  MOVF   52,W
004C:  SUBLW  0A
004D:  BTFSS  03.2
004E:  GOTO   053
....................            { 
....................                 u8StateMashine = 2; 
004F:  MOVLW  02
0050:  MOVWF  71
....................                 u8MsgCount=0; 
0051:  CLRF   72
....................            } 
0052:  GOTO   054
....................            else 
....................            { 
....................                 u8StateMashine = 0; 
0053:  CLRF   71
....................            } 
....................            break; 
0054:  GOTO   194
....................  
....................        case 2://loop 
....................            if(c == 13) 
0055:  MOVLB  01
0056:  MOVF   52,W
0057:  SUBLW  0D
0058:  BTFSS  03.2
0059:  GOTO   05D
....................            { 
....................                 u8StateMashine = 3; 
005A:  MOVLW  03
005B:  MOVWF  71
....................            } 
005C:  GOTO   067
....................            else 
....................            { 
....................                cMsgClock[u8MsgCount] = c; 
005D:  MOVLW  37
005E:  ADDWF  72,W
005F:  MOVWF  04
0060:  MOVLW  20
0061:  MOVWF  05
0062:  BTFSC  03.0
0063:  INCF   05,F
0064:  MOVF   52,W
0065:  MOVWF  00
....................                u8MsgCount++; 
0066:  INCF   72,F
....................                //fputc(c); 
....................            } 
....................            break; 
0067:  GOTO   194
....................  
....................        case 3: 
....................             switch(c) 
0068:  MOVLB  01
0069:  MOVF   52,W
006A:  XORLW  06
006B:  MOVLB  00
006C:  BTFSC  03.2
006D:  GOTO   08D
006E:  XORLW  01
006F:  BTFSC  03.2
0070:  GOTO   0AC
0071:  XORLW  0F
0072:  BTFSC  03.2
0073:  GOTO   0C5
0074:  XORLW  01
0075:  BTFSC  03.2
0076:  GOTO   0D0
0077:  XORLW  03
0078:  BTFSC  03.2
0079:  GOTO   0EB
007A:  XORLW  01
007B:  BTFSC  03.2
007C:  GOTO   0F6
007D:  XORLW  07
007E:  BTFSC  03.2
007F:  GOTO   10D
0080:  XORLW  01
0081:  BTFSC  03.2
0082:  GOTO   118
0083:  XORLW  03
0084:  BTFSC  03.2
0085:  GOTO   133
0086:  XORLW  01
0087:  BTFSC  03.2
0088:  GOTO   151
0089:  XORLW  1F
008A:  BTFSC  03.2
008B:  GOTO   16F
008C:  GOTO   190
....................             { 
....................                 case 6:// set InitialDelay 
....................                     //#013#01023:59:56#013#07 
....................                     putc(13);putc('I');putc('n');putc('i');putc('t'); 
008D:  MOVLW  0D
008E:  CALL   02D
008F:  MOVLW  49
0090:  CALL   02D
0091:  MOVLW  6E
0092:  CALL   02D
0093:  MOVLW  69
0094:  CALL   02D
0095:  MOVLW  74
0096:  CALL   02D
....................                     putc('D');putc('e');putc('l');putc('a');putc('y'); 
0097:  MOVLW  44
0098:  CALL   02D
0099:  MOVLW  65
009A:  CALL   02D
009B:  MOVLW  6C
009C:  CALL   02D
009D:  MOVLW  61
009E:  CALL   02D
009F:  MOVLW  79
00A0:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
00A1:  MOVLW  37
00A2:  ADDWF  72,W
00A3:  MOVWF  04
00A4:  MOVLW  20
00A5:  MOVWF  05
00A6:  BTFSC  03.0
00A7:  INCF   05,F
00A8:  CLRF   00
....................                     u8StateMashine = 0; 
00A9:  CLRF   71
....................                      
....................                     u16ByteFlags |= SetInitialDelayFlagMask; 
00AA:  BSF    4B.1
....................                     break; 
00AB:  GOTO   191
....................                      
....................                 case 7:// set NapDelay 
....................                     //#013#01023:59:56#013#07 
....................                     putc(13);putc('s');putc('n');putc('o');putc('o'); 
00AC:  MOVLW  0D
00AD:  CALL   02D
00AE:  MOVLW  73
00AF:  CALL   02D
00B0:  MOVLW  6E
00B1:  CALL   02D
00B2:  MOVLW  6F
00B3:  CALL   02D
00B4:  MOVLW  6F
00B5:  CALL   02D
....................                     putc('z');putc('e'); 
00B6:  MOVLW  7A
00B7:  CALL   02D
00B8:  MOVLW  65
00B9:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
00BA:  MOVLW  37
00BB:  ADDWF  72,W
00BC:  MOVWF  04
00BD:  MOVLW  20
00BE:  MOVWF  05
00BF:  BTFSC  03.0
00C0:  INCF   05,F
00C1:  CLRF   00
....................                     u8StateMashine = 0; 
00C2:  CLRF   71
....................                      
....................                     u16ByteFlags |= SetSnoozeDelayFlagMask; 
00C3:  BSF    4B.0
....................                     break; 
00C4:  GOTO   191
....................                      
....................                 case 8:// Alarm Test 
....................                     //#013#010X#013#08 
.................... //                    putc(13);putc('A');putc('L');putc('A');putc('R');putc('M');putc('T');putc('E'); 
....................                     cMsgClock[u8MsgCount] = 0; 
00C5:  MOVLW  37
00C6:  ADDWF  72,W
00C7:  MOVWF  04
00C8:  MOVLW  20
00C9:  MOVWF  05
00CA:  BTFSC  03.0
00CB:  INCF   05,F
00CC:  CLRF   00
....................                     u8StateMashine = 0; 
00CD:  CLRF   71
....................                      
....................                     u16ByteFlags |= AddSnoozeDelayFlagMask; 
00CE:  BSF    4B.3
....................                     break; 
00CF:  GOTO   191
....................                      
....................                 case 9:// RESTART 
....................                     //#013#010X#013#09 
....................                     putc(13);putc('R');putc('E');putc('S');putc('T');putc('A');putc('R');putc('T'); 
00D0:  MOVLW  0D
00D1:  CALL   02D
00D2:  MOVLW  52
00D3:  CALL   02D
00D4:  MOVLW  45
00D5:  CALL   02D
00D6:  MOVLW  53
00D7:  CALL   02D
00D8:  MOVLW  54
00D9:  CALL   02D
00DA:  MOVLW  41
00DB:  CALL   02D
00DC:  MOVLW  52
00DD:  CALL   02D
00DE:  MOVLW  54
00DF:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
00E0:  MOVLW  37
00E1:  ADDWF  72,W
00E2:  MOVWF  04
00E3:  MOVLW  20
00E4:  MOVWF  05
00E5:  BTFSC  03.0
00E6:  INCF   05,F
00E7:  CLRF   00
....................                     u8StateMashine = 0; 
00E8:  CLRF   71
....................                      
....................                     reset_cpu(); 
00E9:  RESET
....................                     break; 
00EA:  GOTO   191
....................                      
....................                 case 10:// set CLOCK 
....................                     //#013#01023:59:56#013#010 
....................                     cMsgClock[u8MsgCount] = 0; 
00EB:  MOVLW  37
00EC:  ADDWF  72,W
00ED:  MOVWF  04
00EE:  MOVLW  20
00EF:  MOVWF  05
00F0:  BTFSC  03.0
00F1:  INCF   05,F
00F2:  CLRF   00
....................                     u8StateMashine = 0; 
00F3:  CLRF   71
....................                      
....................                     u16ByteFlags |= SetClockFlagMask; 
00F4:  BSF    4B.5
....................                     break; 
00F5:  GOTO   191
....................  
....................                 case 11:// set ALARM 
....................                     //#013#01023:59:56#013#011 
....................                     putc(13);putc('A');putc('l');putc('a');putc('r');putc('m'); 
00F6:  MOVLW  0D
00F7:  CALL   02D
00F8:  MOVLW  41
00F9:  CALL   02D
00FA:  MOVLW  6C
00FB:  CALL   02D
00FC:  MOVLW  61
00FD:  CALL   02D
00FE:  MOVLW  72
00FF:  CALL   02D
0100:  MOVLW  6D
0101:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
0102:  MOVLW  37
0103:  ADDWF  72,W
0104:  MOVWF  04
0105:  MOVLW  20
0106:  MOVWF  05
0107:  BTFSC  03.0
0108:  INCF   05,F
0109:  CLRF   00
....................                     u8StateMashine = 0; 
010A:  CLRF   71
....................                      
....................                     u16ByteFlags |= SetAlarmFlagMask; 
010B:  BSF    4B.4
....................                     break; 
010C:  GOTO   191
....................  
....................                 case 12:// Reade Clock 
....................                     //#013#010X#013#012 
....................                      
....................                     cMsgClock[u8MsgCount] = 0; 
010D:  MOVLW  37
010E:  ADDWF  72,W
010F:  MOVWF  04
0110:  MOVLW  20
0111:  MOVWF  05
0112:  BTFSC  03.0
0113:  INCF   05,F
0114:  CLRF   00
....................                     u8StateMashine = 0; 
0115:  CLRF   71
....................                      
....................                     u16ByteFlags |= ReadeClockFlagMask; 
0116:  BSF    4B.7
....................                     break; 
0117:  GOTO   191
....................  
....................                 case 13:// effect 
....................                     //#013#010X#013#013 
....................                     putc(13);putc('E');putc('f');putc('f');putc('e');putc('k'); 
0118:  MOVLW  0D
0119:  CALL   02D
011A:  MOVLW  45
011B:  CALL   02D
011C:  MOVLW  66
011D:  CALL   02D
011E:  MOVLW  66
011F:  CALL   02D
0120:  MOVLW  65
0121:  CALL   02D
0122:  MOVLW  6B
0123:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
0124:  MOVLW  37
0125:  ADDWF  72,W
0126:  MOVWF  04
0127:  MOVLW  20
0128:  MOVWF  05
0129:  BTFSC  03.0
012A:  INCF   05,F
012B:  CLRF   00
....................                     u8StateMashine = 0; 
012C:  CLRF   71
....................                     TMR0IE = 1; 
012D:  BSF    0B.5
....................                     u8StaicByteFlags &= ~SleepFlagMask; 
012E:  BCF    4F.1
....................                      
....................                     u1StartFlagGlowAltL = 1; 
012F:  BSF    34.0
....................                      
....................                     u8Moove[5] = 1; 
0130:  MOVLW  01
0131:  MOVWF  2D
....................                     break; 
0132:  GOTO   191
....................  
....................                 case 14:// Debug Print 
....................                     //#013#010X#013#014 
....................                     putc(13);putc('P');putc('r');putc('i');putc('n');putc('t'); 
0133:  MOVLW  0D
0134:  CALL   02D
0135:  MOVLW  50
0136:  CALL   02D
0137:  MOVLW  72
0138:  CALL   02D
0139:  MOVLW  69
013A:  CALL   02D
013B:  MOVLW  6E
013C:  CALL   02D
013D:  MOVLW  74
013E:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
013F:  MOVLW  37
0140:  ADDWF  72,W
0141:  MOVWF  04
0142:  MOVLW  20
0143:  MOVWF  05
0144:  BTFSC  03.0
0145:  INCF   05,F
0146:  CLRF   00
....................                     u8StateMashine = 0; 
0147:  CLRF   71
....................                      
....................                     if( DebugPrintFlagMask == ( u8StaicByteFlags & DebugPrintFlagMask ) ) 
0148:  MOVF   4F,W
0149:  ANDLW  01
014A:  SUBLW  01
014B:  BTFSS  03.2
014C:  GOTO   14F
....................                     { 
....................                         u8StaicByteFlags &= ~DebugPrintFlagMask; 
014D:  BCF    4F.0
....................                     } 
014E:  GOTO   150
....................                     else 
....................                     { 
....................                         u8StaicByteFlags |= DebugPrintFlagMask; 
014F:  BSF    4F.0
....................                     } 
....................                     break; 
0150:  GOTO   191
....................                      
....................                 case 15:// Sleep 
....................                     //#013#010X#013#015 
....................                     putc(13);putc('S');putc('l');putc('e');putc('e');putc('p'); 
0151:  MOVLW  0D
0152:  CALL   02D
0153:  MOVLW  53
0154:  CALL   02D
0155:  MOVLW  6C
0156:  CALL   02D
0157:  MOVLW  65
0158:  CALL   02D
0159:  MOVLW  65
015A:  CALL   02D
015B:  MOVLW  70
015C:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
015D:  MOVLW  37
015E:  ADDWF  72,W
015F:  MOVWF  04
0160:  MOVLW  20
0161:  MOVWF  05
0162:  BTFSC  03.0
0163:  INCF   05,F
0164:  CLRF   00
....................                     u8StateMashine = 0; 
0165:  CLRF   71
.................... 					 
.................... 					if( SleepFlagMask == ( u8StaicByteFlags & SleepFlagMask ) ) 
0166:  MOVF   4F,W
0167:  ANDLW  02
0168:  SUBLW  02
0169:  BTFSS  03.2
016A:  GOTO   16D
.................... 					{ 
.................... 						u8StaicByteFlags &= ~SleepFlagMask; 
016B:  BCF    4F.1
....................                     } 
016C:  GOTO   16E
....................                     else 
....................                     { 
....................                         u8StaicByteFlags |= SleepFlagMask; 
016D:  BSF    4F.1
....................                     } 
....................                     break;  
016E:  GOTO   191
....................                      
....................                 case 16:// 1s Interupt Enable/Disable 
....................                     //#013#010X#013#016 
....................                     putc(13);putc('I');putc('n');putc('t');putc('E');putc('n');putc('1');putc('6'); 
016F:  MOVLW  0D
0170:  CALL   02D
0171:  MOVLW  49
0172:  CALL   02D
0173:  MOVLW  6E
0174:  CALL   02D
0175:  MOVLW  74
0176:  CALL   02D
0177:  MOVLW  45
0178:  CALL   02D
0179:  MOVLW  6E
017A:  CALL   02D
017B:  MOVLW  31
017C:  CALL   02D
017D:  MOVLW  36
017E:  CALL   02D
....................                     cMsgClock[u8MsgCount] = 0; 
017F:  MOVLW  37
0180:  ADDWF  72,W
0181:  MOVWF  04
0182:  MOVLW  20
0183:  MOVWF  05
0184:  BTFSC  03.0
0185:  INCF   05,F
0186:  CLRF   00
....................                     u8StateMashine = 0; 
0187:  CLRF   71
....................                      
....................                     if(0 == DS_Power_Pin) 
0188:  BTFSC  0E.5
0189:  GOTO   18D
....................                     { 
....................                         DS_Power_Pin = 1; 
018A:  BSF    0E.5
....................                         IOCIE = 1;// Interrupt-on-Change Enable bit 
018B:  BSF    0B.3
....................                     } 
018C:  GOTO   18F
....................                     else 
....................                     { 
....................                         DS_Power_Pin = 0; 
018D:  BCF    0E.5
....................                         IOCIE = 0;// Interrupt-on-Change Enable bit 
018E:  BCF    0B.3
....................                     } 
....................                     break;  
018F:  GOTO   191
....................                      
....................                 default: 
....................                     u8StateMashine = 0; 
0190:  CLRF   71
....................                     break; 
....................             } 
....................         break; 
0191:  MOVLB  01
0192:  GOTO   194
0193:  MOVLB  01
....................    } 
.................... } 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include "DS1307.c" 
....................  
.................... #include "DS1307.h" 
....................  
....................  
....................  
.................... #ifndef DS 
.................... #define	DS 
....................  
.................... #include "ClockCalculationTransformation.c" 
....................  
.................... //============================================================================== 
.................... // PRIVATE MACROS 
.................... //============================================================================== 
.................... #define     DS3231_WriteX    0xD0 
.................... #define     DS3231_ReadX     0xD1 
....................  
.................... /*          DaynamicFlags       */ 
....................  
.................... #define     SetSnoozeDelayFlagMask      0x0001    //0b00000000 00000001 
.................... #define     SetInitialDelayFlagMask     0x0002    //0b00000000 00000010 
.................... #define     EffectIncrementFlagMask     0x0004    //0b00000000 00000100 
.................... #define     AddSnoozeDelayFlagMask      0x0008    //0b00000000 00001000 
.................... #define     SetAlarmFlagMask            0x0010    //0b00000000 00010000 
.................... #define     SetClockFlagMask            0x0020    //0b00000000 00100000 
.................... #define     OneSecondTaskFlagMask       0x0040    //0b00000000 01000000 
.................... #define     ReadeClockFlagMask          0x0080    //0b00000000 10000000 
.................... //u16ByteFlags2 
.................... #define     SleepDelayFlagMask          0x0001    //0b00000001 00000000 
....................  
.................... /*          StaticFlags       */ 
.................... #define     DebugPrintFlagMask          0x01    //0b00000001 
.................... #define     SleepFlagMask               0x02    //0b00000010 
.................... //TBD 
.................... //#define     u1StartFlagGlowAltL         0x04    //0b00000100 
....................  
.................... #define     DebugPrintClock     0x01 
....................  
.................... #Bit    DS_Power_Pin_TRIS   =   TRISC.5 
.................... #Bit    DS_Power_Pin        =   PORTC.5 
....................  
.................... void ds1307_write_test(unsigned char rtcreg, unsigned int8 rtc_data); 
.................... uint8 DS_Write_Test(unsigned char rtcreg, unsigned int8 rtc_data); 
....................  
.................... void min_inc(void); 
.................... void hour_inc(void); 
....................  
.................... void DS_Task(void); 
....................  
.................... void DS_Init(void); 
.................... void DS_Init_Clock(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_Data(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_OutClock(void); 
....................  
.................... void DS_Read_Clock(uint8 *pDataP); 
.................... void DS_Read_Data(uint8 *pDataP); 
....................  
.................... void DS_Print_Clock(uint8 *pDataP); 
.................... void DS_Print_Data(uint8 *pDataP); 
....................  
.................... void DS_Write(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
.................... void DS_Read(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... void DS_String_To_Massiv_Clock(uint8 * u8ClockSetP, char * cMsgClock); 
.................... void DS_String_To_Massiv_Data(uint8 * u8DateSetP, char * cMsgClock); 
....................  
.................... void SetSnoozeDelay(char * cMsgClockP); 
.................... void SetInitialDelay(char * cMsgClockP); 
....................  
.................... void DecodeClock(char * cMsgClock); 
.................... void DecodeData(char * cMsgClock); 
....................  
.................... uint8 DS_Reade_Pointer(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... uint8 Comppare_Time(uint8 *pDataP, uint8 *pAlarmP); 
.................... //uint8 Check_Sequences(uint8 *pDataP); 
.................... void Menage_Alarma(uint8 *pDataP); 
.................... void SetAlarm(void); 
.................... void AddTimeToAlarm(void); 
....................  
.................... //unsigned int8 rtensec; 
.................... //unsigned int8 rsec; 
.................... //unsigned int8 rtenmin; 
.................... //unsigned int8 rmin; 
.................... //unsigned int8 rtenhour; 
.................... //unsigned int8 rhour; 
.................... //unsigned int8 rday; 
.................... //unsigned int8 rtendate; 
.................... //unsigned int8 rdate; 
.................... //unsigned int8 rmonth; 
.................... //unsigned int8 rtenmonth; 
.................... //unsigned int8 rtenyear; 
.................... //unsigned int8 ryear; 
....................  
.................... unsigned int16 u16TaskTimeCounterL = 0; 
....................  
.................... unsigned int8 u8Alarm[6] = {5,9,5,9,0,0}; 
....................  
.................... unsigned int8 u8InitialDelay[6] = {0,0,3,0,0,4}; 
....................  
.................... unsigned int8 u8SnoozeDelay[6] = {5,9,5,9,2,3}; 
....................  
....................  
.................... //unsigned int8 u8ReadeClockFlag = 0; 
.................... //unsigned int8 u8SetDataFlag = 0; 
.................... //unsigned int8 u8DebugPrintFlag = 0; 
....................  
.................... //unsigned int8 u8SetNapDelayFlag = 0; 
....................  
.................... unsigned int16 u16ByteFlags = 0; 
.................... unsigned int16 u16ByteFlags2 = 0; 
.................... unsigned int8 u8StaicByteFlags = (SleepFlagMask || DebugPrintFlagMask); 
....................  
.................... #define TenSec      0 
.................... #define Sec         1 
.................... #define TenMin      2 
.................... #define Min         3 
.................... #define TenHour     4 
.................... #define Hour        5 
....................  
.................... #define AlarmTenSec      0 
.................... #define AlarmSec         1 
.................... #define AlarmTenMin      2 
.................... #define AlarmMin         3 
.................... #define AlarmTenHour     4 
.................... #define AlarmHour        5 
....................  
.................... #define Day         6 
....................  
.................... #define TenDate     0 
.................... #define Date        1 
.................... #define Month       2 
.................... #define TenMonth    3 
.................... #define TenYear     4 
.................... #define Year        5 
....................  
.................... //TBD 0b - 0x 
.................... #define Sec_Mask             0b00001111 
.................... #define TenSec_Mask          0b01110000 
.................... #define Min_Mask             0b00001111 
.................... #define TenMin_Mask          0b01110000 
.................... #define Hour_Mask            0b00001111 
.................... #define TenHour_Mask         0b00110000 
....................  
.................... #define Day_Mask             0b00000111 
.................... #define Date_Mask            0b00001111 
.................... #define TenDate_Mask         0b00110000 
.................... #define Month_Mask           0b00001111 
.................... #define TenMonth_Mask        0b00010000 
.................... #define Year_Mask            0b00001111 
.................... #define TenYear_Mask         0b11110000 
....................  
.................... #define Monday      1 
.................... #define Tuesday     2 
.................... #define Wednesday   3 
.................... #define Thursday    4 
.................... #define Friday      5 
.................... #define Saturday    6 
.................... #define Sunday      7 
....................  
.................... #endif	/* DS*/ 
....................  
.................... #include "DS13XX.h" 
0194:  MOVLB  00
0195:  BCF    11.5
0196:  MOVLP  00
0197:  GOTO   01E
.................... #ifndef DS13XX 
.................... #define	DS13XX 
....................  
.................... void DS_Print_Clock_3by(uint8 *pDataP, uint8 u8NewLineP); 
.................... void DS_Read_Clock_3by(uint8 *pDataP); 
.................... void DS_String_To_Massiv_Clock_3by(uint8 * u8ClockSetP, char * cMsgClockP); 
.................... void DS_Init_Clock_3by(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DecodeInitPrintClock_3by(char * cMsgClockP); 
....................  
.................... void SetSnoozeDelay_3by(char * cMsgClockP); 
.................... void SetInitialDelay_3by(char * cMsgClockP); 
....................  
.................... void AddTimeToAlarm_3by(void); 
....................  
.................... #endif 
....................  
....................  
.................... //-------------------- Formats date and time 
.................... void Transform_Time() { 
.................... //  seconds  =  ((seconds & 0xF0) >> 4)*10 + (seconds & 0x0F);  // Transform seconds 
.................... //  minutes  =  ((minutes & 0xF0) >> 4)*10 + (minutes & 0x0F);  // Transform months 
.................... //  hours    =  ((hours & 0xF0)  >> 4)*10  + (hours & 0x0F);    // Transform hours 
.................... //  year     =   (day & 0xC0) >> 6;                             // Transform year 
.................... //  day      =  ((day & 0x30) >> 4)*10    + (day & 0x0F);       // Transform day 
.................... //  month    =  ((month & 0x10)  >> 4)*10 + (month & 0x0F);     // Transform month 
.................... } 
....................  
.................... //-------------------- Output values to LCD 
.................... void Display_Time() { 
....................  
.................... //   (day / 10)   + 48);    // Print tens digit of day variable 
.................... //   (day % 10)   + 48);    // Print oness digit of day variable 
.................... //   (month / 10) + 48); 
.................... //   (month % 10) + 48); 
.................... //   Lcd_Chr(1,15,  year        + 49);    // Print year vaiable + 1 (start from year 2011) 
....................  
.................... //    (hours / 10)   + 48); 
.................... //    (hours % 10)   + 48); 
.................... //    (minutes / 10) + 48); 
.................... //    (minutes % 10) + 48); 
.................... //    (seconds / 10) + 48); 
.................... //    (seconds % 10) + 48); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Task(void) 
.................... { 
....................     uint8 DataL[16]; 
....................     u16TaskTimeCounterL++; 
*
08C1:  INCF   37,F
08C2:  BTFSC  03.2
08C3:  INCF   38,F
.................... //    printf("\n\r%Lu",u16TaskTimeCounterL); 
....................     if(1 == u16TaskTimeCounterL) 
08C4:  DECFSZ 37,W
08C5:  GOTO   222
08C6:  MOVF   38,F
08C7:  BTFSS  03.2
08C8:  GOTO   222
....................     { 
....................         DS_Read_Clock(DataL); 
08C9:  MOVLW  20
08CA:  MOVLB  01
08CB:  MOVWF  3F
08CC:  MOVLW  5B
08CD:  MOVWF  3E
08CE:  MOVLP  00
08CF:  MOVLB  00
08D0:  CALL   7B8
08D1:  MOVLP  08
....................         if( DebugPrintFlagMask == ( u8StaicByteFlags & DebugPrintFlagMask ) ) 
08D2:  MOVF   4F,W
08D3:  ANDLW  01
08D4:  SUBLW  01
08D5:  BTFSS  03.2
08D6:  GOTO   199
....................         { 
....................             putc(13);putc('C');putc('l');putc('o');putc('c');putc('k'); 
08D7:  MOVLW  0D
08D8:  MOVLP  00
08D9:  CALL   02D
08DA:  MOVLP  08
08DB:  MOVLW  43
08DC:  MOVLP  00
08DD:  CALL   02D
08DE:  MOVLP  08
08DF:  MOVLW  6C
08E0:  MOVLP  00
08E1:  CALL   02D
08E2:  MOVLP  08
08E3:  MOVLW  6F
08E4:  MOVLP  00
08E5:  CALL   02D
08E6:  MOVLP  08
08E7:  MOVLW  63
08E8:  MOVLP  00
08E9:  CALL   02D
08EA:  MOVLP  08
08EB:  MOVLW  6B
08EC:  MOVLP  00
08ED:  CALL   02D
08EE:  MOVLP  08
....................             putc(' ');putc(' ');putc(' ');putc(' ');putc(' '); 
08EF:  MOVLW  20
08F0:  MOVLP  00
08F1:  CALL   02D
08F2:  MOVLP  08
08F3:  MOVLW  20
08F4:  MOVLP  00
08F5:  CALL   02D
08F6:  MOVLP  08
08F7:  MOVLW  20
08F8:  MOVLP  00
08F9:  CALL   02D
08FA:  MOVLP  08
08FB:  MOVLW  20
08FC:  MOVLP  00
08FD:  CALL   02D
08FE:  MOVLP  08
08FF:  MOVLW  20
0900:  MOVLP  00
0901:  CALL   02D
0902:  MOVLP  08
....................             putc('A');putc('l');putc('a');putc('r');putc('m'); 
0903:  MOVLW  41
0904:  MOVLP  00
0905:  CALL   02D
0906:  MOVLP  08
0907:  MOVLW  6C
0908:  MOVLP  00
0909:  CALL   02D
090A:  MOVLP  08
090B:  MOVLW  61
090C:  MOVLP  00
090D:  CALL   02D
090E:  MOVLP  08
090F:  MOVLW  72
0910:  MOVLP  00
0911:  CALL   02D
0912:  MOVLP  08
0913:  MOVLW  6D
0914:  MOVLP  00
0915:  CALL   02D
0916:  MOVLP  08
....................              
....................             putc(10);putc(13); 
0917:  MOVLW  0A
0918:  MOVLP  00
0919:  CALL   02D
091A:  MOVLP  08
091B:  MOVLW  0D
091C:  MOVLP  00
091D:  CALL   02D
091E:  MOVLP  08
....................             DS_Print_Clock(DataL); 
091F:  MOVLW  20
0920:  MOVLB  01
0921:  MOVWF  3C
0922:  MOVLW  5B
0923:  MOVWF  3B
....................             putc(' ');putc(' '); 
*
097F:  MOVLW  20
0980:  MOVLP  00
0981:  CALL   02D
0982:  MOVLP  08
0983:  MOVLW  20
0984:  MOVLP  00
0985:  CALL   02D
0986:  MOVLP  08
....................             DS_Print_Clock_3by(u8Alarm,0); 
0987:  MOVLW  20
0988:  MOVLB  01
0989:  MOVWF  3C
098A:  MOVLW  19
098B:  MOVWF  3B
098C:  CLRF   3D
098D:  MOVLP  00
098E:  MOVLB  00
098F:  CALL   401
0990:  MOVLP  08
....................             putc(10);putc(13); 
0991:  MOVLW  0A
0992:  MOVLP  00
0993:  CALL   02D
0994:  MOVLP  08
0995:  MOVLW  0D
0996:  MOVLP  00
0997:  CALL   02D
0998:  MOVLP  08
....................         } 
....................         Menage_Alarma(DataL); 
0999:  MOVLW  20
099A:  MOVLB  01
099B:  MOVWF  3C
099C:  MOVLW  5B
099D:  MOVWF  3B
....................  
....................         u16TaskTimeCounterL=0; 
*
0A1F:  MOVLB  00
0A20:  CLRF   38
0A21:  CLRF   37
....................     } 
0A22:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Init(void) 
*
02EC:  CLRF   2B
.................... { 
....................     uint8 u8WaitForComunicationL=0; 
....................     uint8 u8Data[6]; 
....................  
....................     DS_Power_Pin_TRIS = 0;//B0 enable communication power of DS1338 
02ED:  BCF    0E.5
....................     DS_Power_Pin = 1;//outputs B0 is high to power DS1338 
02EE:  MOVLB  00
02EF:  BSF    0E.5
....................     Delay_ms(10); 
02F0:  MOVLW  0A
02F1:  MOVLB  01
02F2:  MOVWF  32
02F3:  MOVLB  00
02F4:  CALL   1F6
....................     do 
....................     { 
....................         u8WaitForComunicationL = DS_Write_Test(1,0b00000100); 
02F5:  MOVLW  01
02F6:  MOVLB  01
02F7:  MOVWF  32
02F8:  MOVLW  04
02F9:  MOVWF  33
*
034A:  MOVF   78,W
034B:  MOVLB  01
034C:  MOVWF  2B
....................         Delay_ms(100); 
034D:  MOVLW  64
034E:  MOVWF  32
034F:  MOVLB  00
0350:  CALL   1F6
....................     }while(0 == u8WaitForComunicationL); 
0351:  MOVLB  01
0352:  MOVF   2B,F
0353:  BTFSS  03.2
0354:  GOTO   357
0355:  MOVLB  00
0356:  GOTO   2F5
....................  
....................     DS_Init_Clock(0,u8Data); 
0357:  CLRF   32
0358:  MOVLW  20
0359:  MOVWF  34
035A:  MOVLW  5C
035B:  MOVWF  33
....................     DS_Init_OutClock(); 
*
03E7:  NOP
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Menage_Alarma(uint8 *pDataP) 
*
099E:  CLRF   3D
.................... { 
....................     uint8 u8IsAlarmTimeL = 0; 
....................     DS_Read_Clock(pDataP); 
099F:  MOVF   3C,W
09A0:  MOVWF  3F
09A1:  MOVF   3B,W
09A2:  MOVWF  3E
09A3:  MOVLP  00
09A4:  MOVLB  00
09A5:  CALL   7B8
09A6:  MOVLP  08
....................     u8IsAlarmTimeL = Comppare_Time( pDataP, u8Alarm ); 
09A7:  MOVLB  01
09A8:  MOVF   3C,W
09A9:  MOVWF  3F
09AA:  MOVF   3B,W
09AB:  MOVWF  3E
09AC:  MOVLW  20
09AD:  MOVWF  41
09AE:  MOVLW  19
09AF:  MOVWF  40
*
0A15:  MOVF   78,W
0A16:  MOVWF  3D
....................  
....................     if(1 == u8IsAlarmTimeL) 
0A17:  DECFSZ 3D,W
0A18:  GOTO   21F
....................     { 
....................         u8Moove[5] = 1; 
0A19:  MOVLW  01
0A1A:  MOVLB  00
0A1B:  MOVWF  2D
....................         u1StartFlagGlowAltL = 1; 
0A1C:  BSF    34.0
....................         u8StaicByteFlags &= ~SleepFlagMask; 
0A1D:  BCF    4F.1
0A1E:  MOVLB  01
....................     } 
....................      
.................... //    printf("\n\r%d%d:%d%d:%d%d CHAS",pDataP[TenHour],pDataP[Hour], 
.................... //                            pDataP[TenMin],pDataP[Min], 
.................... //                            pDataP[TenSec],pDataP[Sec]); 
.................... // 
.................... //    printf("\n\r%d%d:%d%d:%d%d   Alarm",u8Alarm[TenHour],u8Alarm[Hour], 
.................... //                                u8Alarm[TenMin],u8Alarm[Min], 
.................... //                                u8Alarm[TenSec],u8Alarm[Sec]); 
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void SetAlarm(void) 
.................... { 
....................     DS_String_To_Massiv_Clock(u8Alarm,cMsgClock); 
....................  
.................... //    printf("\n\r%d%d:%d%d:%d%d   Set Alarm",u8Alarm[TenHour],u8Alarm[Hour], 
.................... //                                u8Alarm[TenMin],u8Alarm[Min], 
.................... //                                u8Alarm[TenSec],u8Alarm[Sec]); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void AddTimeToAlarm(void) 
.................... { 
....................     uint8 u8AlarmTempL[7]; 
....................     uint8 u8SnoozeDelayTempL[7]; 
....................      
....................     putc(13); 
....................     putc('O');putc('l');putc('d');putc('A');putc('l');putc('a'); 
....................     putc('r');putc('m'); 
....................     putc(' ');putc(' '); 
....................     putc('S');putc('n');putc('o');putc('o');putc('z');putc('e'); 
....................  
....................     putc(10);putc(13); 
....................     DS_Print_Clock(u8Alarm); 
....................     putc(' ');putc(' '); 
....................     DS_Print_Clock(u8SnoozeDelay); 
....................     putc(10);putc(13); 
....................              
....................     DigitsToInt ( u8Alarm, u8AlarmTempL ); 
....................     DigitsToInt ( u8SnoozeDelay, u8SnoozeDelayTempL ); 
....................  
....................     AddTimeToClock( u8AlarmTempL, u8SnoozeDelayTempL ); 
....................     IntToDigits ( u8AlarmTempL, u8Alarm); 
....................  
....................     putc('N');putc('e');putc('w'); 
....................     putc('A');putc('l');putc('a');putc('r');putc('m'); 
....................     putc(10);putc(13); 
....................     DS_Print_Clock(u8Alarm); 
....................      
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 Comppare_Time(uint8 *pDataP, uint8 *pAlarmP) 
*
09B0:  CLRF   42
.................... { 
....................     uint8 u8ReturnL = 0; 
....................     if((pDataP[TenHour] == pAlarmP[TenHour]) && 
....................              (pDataP[Hour] == pAlarmP[Hour]) && 
....................          (pDataP[TenMin] == pAlarmP[TenMin]) && 
....................                (pDataP[Min] == pAlarmP[Min]) && 
....................          (pDataP[TenSec] == pAlarmP[TenSec]) && 
....................               (pDataP[Sec] == pAlarmP[Sec])) 
09B1:  MOVF   3E,W
09B2:  MOVWF  04
09B3:  MOVF   3F,W
09B4:  MOVWF  05
09B5:  ADDFSR 04,FSR0
09B6:  MOVF   00,W
09B7:  MOVWF  43
09B8:  MOVF   40,W
09B9:  MOVWF  04
09BA:  MOVF   41,W
09BB:  MOVWF  05
09BC:  ADDFSR 04,FSR0
09BD:  MOVF   00,W
09BE:  SUBWF  43,W
09BF:  BTFSS  03.2
09C0:  GOTO   213
09C1:  MOVF   3E,W
09C2:  MOVWF  04
09C3:  MOVF   3F,W
09C4:  MOVWF  05
09C5:  ADDFSR 05,FSR0
09C6:  MOVF   00,W
09C7:  MOVWF  43
09C8:  MOVF   40,W
09C9:  MOVWF  04
09CA:  MOVF   41,W
09CB:  MOVWF  05
09CC:  ADDFSR 05,FSR0
09CD:  MOVF   00,W
09CE:  SUBWF  43,W
09CF:  BTFSS  03.2
09D0:  GOTO   213
09D1:  MOVF   3E,W
09D2:  MOVWF  04
09D3:  MOVF   3F,W
09D4:  MOVWF  05
09D5:  ADDFSR 02,FSR0
09D6:  MOVF   00,W
09D7:  MOVWF  43
09D8:  MOVF   40,W
09D9:  MOVWF  04
09DA:  MOVF   41,W
09DB:  MOVWF  05
09DC:  ADDFSR 02,FSR0
09DD:  MOVF   00,W
09DE:  SUBWF  43,W
09DF:  BTFSS  03.2
09E0:  GOTO   213
09E1:  MOVF   3E,W
09E2:  MOVWF  04
09E3:  MOVF   3F,W
09E4:  MOVWF  05
09E5:  ADDFSR 03,FSR0
09E6:  MOVF   00,W
09E7:  MOVWF  43
09E8:  MOVF   40,W
09E9:  MOVWF  04
09EA:  MOVF   41,W
09EB:  MOVWF  05
09EC:  ADDFSR 03,FSR0
09ED:  MOVF   00,W
09EE:  SUBWF  43,W
09EF:  BTFSS  03.2
09F0:  GOTO   213
09F1:  MOVF   3E,W
09F2:  MOVWF  04
09F3:  MOVF   3F,W
09F4:  MOVWF  05
09F5:  ADDFSR 00,FSR0
09F6:  MOVF   00,W
09F7:  MOVWF  43
09F8:  MOVF   40,W
09F9:  MOVWF  04
09FA:  MOVF   41,W
09FB:  MOVWF  05
09FC:  ADDFSR 00,FSR0
09FD:  MOVF   00,W
09FE:  SUBWF  43,W
09FF:  BTFSS  03.2
0A00:  GOTO   213
0A01:  MOVF   3E,W
0A02:  MOVWF  04
0A03:  MOVF   3F,W
0A04:  MOVWF  05
0A05:  ADDFSR 01,FSR0
0A06:  MOVF   00,W
0A07:  MOVWF  43
0A08:  MOVF   40,W
0A09:  MOVWF  04
0A0A:  MOVF   41,W
0A0B:  MOVWF  05
0A0C:  ADDFSR 01,FSR0
0A0D:  MOVF   00,W
0A0E:  SUBWF  43,W
0A0F:  BTFSS  03.2
0A10:  GOTO   213
....................     { 
....................         u8ReturnL = 1; 
0A11:  MOVLW  01
0A12:  MOVWF  42
....................     } 
....................     return u8ReturnL; 
0A13:  MOVF   42,W
0A14:  MOVWF  78
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void hour_inc(void) 
.................... { 
.................... //unsigned char flag_inc=0; 
.................... // 
.................... //    if( !input(PIN_B4)) 
.................... //    { 
.................... //        delay_ms(170); 
.................... //        read_rtc(); 
.................... //        if(!input_state(pin_B2)) 
.................... //        { 
.................... //            output_bit(PIN_B2,1); 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            output_bit(PIN_B2,0); 
.................... //        } 
.................... //        flag_inc=1; 
.................... //        if((rtenhour==1)|(rtenhour==0)) 
.................... //        { 
.................... //            rhour++; 
.................... //            if(rhour==10) 
.................... //            { 
.................... //                rhour=0; 
.................... //                rtenhour++; 
.................... //                if(rtenhour==10) 
.................... //                { 
.................... //                    rtenhour=0; 
.................... //                } 
.................... //            } 
.................... //        } 
.................... // 
.................... //        if(rtenhour==2) 
.................... //        { 
.................... //            rhour++; 
.................... //            if(rhour==4) 
.................... //            { 
.................... //                rhour=0; 
.................... //                rtenhour=0; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //    if(flag_inc) 
.................... //    { 
.................... //        rtc_init(1); 
.................... //        print_hour_ds1307(); 
.................... //    } 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void min_inc(void) 
.................... { 
.................... //    unsigned char flag_inc=0; 
.................... // 
.................... //    if( !input(PIN_B3)) 
.................... //    { 
.................... //        delay_ms(170); 
.................... //        read_rtc(); 
.................... //        if(!input_state(pin_B2)) 
.................... //        { 
.................... //            output_bit(PIN_B2,1); 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            output_bit(PIN_B2,0); 
.................... //        } 
.................... //        flag_inc=1; 
.................... //        rmin++; 
.................... //        if(rmin==10) 
.................... //        { 
.................... //            rmin=0; 
.................... //            rtenmin++; 
.................... //            if(rtenmin==6) 
.................... //            { 
.................... //                rtenmin=0; 
.................... //            } 
.................... //        } 
.................... //    } 
.................... //    if(flag_inc) 
.................... //    { 
.................... //        rtc_init(1); 
.................... //        print_hour_ds1307(); 
.................... //    } 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Init_Clock(uint8 u8FlagInitP, uint8 *pDataP) 
*
035C:  MOVLW  05
035D:  MOVWF  35
035E:  CLRF   36
035F:  MOVWF  37
0360:  MOVLW  09
0361:  MOVWF  38
0362:  MOVLW  02
0363:  MOVWF  39
0364:  MOVLW  03
0365:  MOVWF  3A
.................... { 
....................     uint8 u8TenSecL=5; 
....................     uint8 u8SecL=0; 
....................     uint8 u8TenMinL=5; 
....................     uint8 u8MinL=9; 
....................     uint8 u8TenHourL=2; 
....................     uint8 u8HourL=3; 
....................  
....................     if( u8FlagInitP == 1) 
0366:  DECFSZ 32,W
0367:  GOTO   38C
....................     { 
....................         u8TenSecL   = pDataP[TenSec]; 
0368:  MOVF   33,W
0369:  MOVWF  04
036A:  MOVF   34,W
036B:  MOVWF  05
036C:  MOVIW  [FSR0+00],W
036D:  MOVWF  35
....................         u8SecL      = pDataP[Sec]; 
036E:  MOVF   33,W
036F:  MOVWF  04
0370:  MOVF   34,W
0371:  MOVWF  05
0372:  MOVIW  [FSR0+01],W
0373:  MOVWF  36
....................         u8TenMinL   = pDataP[TenMin]; 
0374:  MOVF   33,W
0375:  MOVWF  04
0376:  MOVF   34,W
0377:  MOVWF  05
0378:  MOVIW  [FSR0+02],W
0379:  MOVWF  37
....................         u8MinL      = pDataP[Min]; 
037A:  MOVF   33,W
037B:  MOVWF  04
037C:  MOVF   34,W
037D:  MOVWF  05
037E:  MOVIW  [FSR0+03],W
037F:  MOVWF  38
....................         u8TenHourL  = pDataP[TenHour]; 
0380:  MOVF   33,W
0381:  MOVWF  04
0382:  MOVF   34,W
0383:  MOVWF  05
0384:  MOVIW  [FSR0+04],W
0385:  MOVWF  39
....................         u8HourL     = pDataP[Hour]; 
0386:  MOVF   33,W
0387:  MOVWF  04
0388:  MOVF   34,W
0389:  MOVWF  05
038A:  MOVIW  [FSR0+05],W
038B:  MOVWF  3A
....................     } 
....................  
....................     u8SecL&=Sec_Mask; 
038C:  MOVLW  0F
038D:  ANDWF  36,F
....................     u8MinL&=Min_Mask; 
038E:  ANDWF  38,F
....................     u8HourL&=Hour_Mask; 
038F:  ANDWF  3A,F
....................  
....................     u8TenSecL <<= 4; 
0390:  SWAPF  35,F
0391:  MOVLW  F0
0392:  ANDWF  35,F
....................     u8TenMinL <<= 4; 
0393:  SWAPF  37,F
0394:  ANDWF  37,F
....................     u8TenHourL <<= 4; 
0395:  SWAPF  39,F
0396:  ANDWF  39,F
....................  
....................     u8TenSecL &= TenSec_Mask; 
0397:  MOVLW  70
0398:  ANDWF  35,F
....................     u8TenMinL &= TenMin_Mask; 
0399:  ANDWF  37,F
....................     u8TenHourL &= TenHour_Mask; 
039A:  MOVLW  30
039B:  ANDWF  39,F
....................  
....................     u8SecL|=u8TensecL; 
039C:  MOVF   35,W
039D:  IORWF  36,F
....................     u8MinL|=u8TenMinL; 
039E:  MOVF   37,W
039F:  IORWF  38,F
....................     u8HourL|=u8TenHourL; 
03A0:  MOVF   39,W
03A1:  IORWF  3A,F
....................  
....................     u8SecL &= (~0b10000000);// the oscillator is enabled 
03A2:  BCF    36.7
....................      
.................... //    pDataP[Sec]     = (u8SecL & Sec_Mask); 
.................... //    pDataP[TenSec]  = ((u8SecL & TenSec_Mask)>>4); 
.................... //    pDataP[Min]     = (u8MinL & Min_Mask); 
.................... //    pDataP[TenMin]  = ((u8MinL & TenMin_Mask)>>4); 
.................... //    pDataP[Hour]    = (u8HourL & Hour_Mask); 
.................... //    pDataP[TenHour] = ((u8HourL & TenHour_Mask)>>4); 
.................... // 
.................... //        printf("\n\r%d%d:%d%d:%d%d",pDataP[TenHour],pDataP[Hour], 
.................... //                           pDataP[TenMin],pDataP[Min], 
.................... //                           pDataP[TenSec],pDataP[Sec]); 
....................  
....................  
....................     DS_Write(0,&u8SecL,1); 
03A3:  CLRF   3B
03A4:  MOVLW  20
03A5:  MOVWF  3D
03A6:  MOVLW  66
03A7:  MOVWF  3C
03A8:  MOVLW  01
03A9:  MOVWF  3E
03AA:  MOVLB  00
03AB:  CALL   225
....................     DS_Write(1,&u8MinL,1); 
03AC:  MOVLW  01
03AD:  MOVLB  01
03AE:  MOVWF  3B
03AF:  MOVLW  20
03B0:  MOVWF  3D
03B1:  MOVLW  68
03B2:  MOVWF  3C
03B3:  MOVLW  01
03B4:  MOVWF  3E
03B5:  MOVLB  00
03B6:  CALL   225
....................     DS_Write(2,&u8HourL,1); 
03B7:  MOVLW  02
03B8:  MOVLB  01
03B9:  MOVWF  3B
03BA:  MOVLW  20
03BB:  MOVWF  3D
03BC:  MOVLW  6A
03BD:  MOVWF  3C
03BE:  MOVLW  01
03BF:  MOVWF  3E
03C0:  MOVLB  00
03C1:  CALL   225
03C2:  NOP
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Init_Data(uint8 u8FlagInitP, uint8 *pDataP) 
.................... { 
....................     uint8 u8TenDateL    =1; 
....................     uint8 u8DateL       =4; 
....................  
....................     uint8 u8TenMonthL   =0; 
....................     uint8 u8MonthL      =3; 
....................  
....................     uint8 u8TenYearL    =0; 
....................     uint8 u8YearL       =4; 
....................  
....................     if(u8FlagInitP == 1) 
....................     { 
....................         u8TenDateL  = pDataP[TenDate]; 
....................         u8DateL     = pDataP[Date]; 
....................         u8TenMonthL = pDataP[TenMonth]; 
....................         u8MonthL    = pDataP[Month]; 
....................         u8TenYearL  = pDataP[TenYear]; 
....................         u8YearL     = pDataP[Year]; 
....................     } 
....................  
....................     u8DateL &= Date_Mask; 
....................     u8MonthL &= Month_Mask; 
....................     u8YearL &= Year_Mask; 
....................  
....................     u8TenDateL  <<= 4; 
....................     u8TenMonthL <<= 4; 
....................     u8TenYearL  <<= 4; 
....................  
....................     u8TenDateL  &= TenDate_Mask; 
....................     u8TenMonthL &= TenMonth_Mask; 
....................     u8TenYearL  &= TenYear_Mask; 
....................  
....................     u8DateL |= u8TenDateL; 
....................     u8MonthL |= u8TenMonthL; 
....................     u8YearL |= u8TenYearL; 
....................  
....................     DS_Write(4,&u8DateL,1); 
....................     DS_Write(5,&u8MonthL,1); 
....................     DS_Write(6,&u8YearL,1); 
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Init_OutClock(void) 
03C3:  MOVLB  01
03C4:  CLRF   32
.................... { 
....................     uint8 u8ClockOutL = 0; 
....................  
....................     DS_Reade_Pointer(0, &u8ClockOutL, 1); 
03C5:  CLRF   43
03C6:  MOVLW  20
03C7:  MOVWF  45
03C8:  MOVLW  62
03C9:  MOVWF  44
03CA:  MOVLW  01
03CB:  MOVWF  46
03CC:  MOVLB  00
03CD:  CALL   262
....................     u8ClockOutL &= (~0b10000000);// the oscillator is enabled 
03CE:  MOVLB  01
03CF:  BCF    32.7
....................     DS_Write(0,&u8ClockOutL,1); 
03D0:  CLRF   3B
03D1:  MOVLW  20
03D2:  MOVWF  3D
03D3:  MOVLW  62
03D4:  MOVWF  3C
03D5:  MOVLW  01
03D6:  MOVWF  3E
03D7:  MOVLB  00
03D8:  CALL   225
....................  
....................     u8ClockOutL = 0b00010000;//1 Hz output 
03D9:  MOVLW  10
03DA:  MOVLB  01
03DB:  MOVWF  32
....................     DS_Write(7,&u8ClockOutL,1); 
03DC:  MOVLW  07
03DD:  MOVWF  3B
03DE:  MOVLW  20
03DF:  MOVWF  3D
03E0:  MOVLW  62
03E1:  MOVWF  3C
03E2:  MOVLW  01
03E3:  MOVWF  3E
03E4:  MOVLB  00
03E5:  CALL   225
03E6:  NOP
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Print_Clock(uint8 *pDataP) 
.................... { 
.................... //    DS_Read_Clock(pDataP); 
.................... //    printf("\n\r%d%d:%d%d:%d%d",pDataP[TenHour],pDataP[Hour], 
.................... //                                pDataP[TenMin],pDataP[Min], 
.................... //                                pDataP[TenSec],pDataP[Sec]); 
.................... //    printf("\n\r"); 
.................... //    putc(10); 
.................... //    putc(13); 
....................     putc(pDataP[TenHour]+48); 
*
0924:  MOVF   3B,W
0925:  MOVWF  04
0926:  MOVF   3C,W
0927:  MOVWF  05
0928:  ADDFSR 04,FSR0
0929:  MOVLW  30
092A:  ADDWF  00,W
092B:  MOVWF  3D
092C:  MOVF   3D,W
092D:  MOVLP  00
092E:  MOVLB  00
092F:  CALL   02D
0930:  MOVLP  08
....................     putc(pDataP[Hour]+48); 
0931:  MOVLB  01
0932:  MOVF   3B,W
0933:  MOVWF  04
0934:  MOVF   3C,W
0935:  MOVWF  05
0936:  ADDFSR 05,FSR0
0937:  MOVLW  30
0938:  ADDWF  00,W
0939:  MOVWF  3D
093A:  MOVF   3D,W
093B:  MOVLP  00
093C:  MOVLB  00
093D:  CALL   02D
093E:  MOVLP  08
....................     putc(58); 
093F:  MOVLW  3A
0940:  MOVLP  00
0941:  CALL   02D
0942:  MOVLP  08
....................     putc(pDataP[TenMin]+48); 
0943:  MOVLB  01
0944:  MOVF   3B,W
0945:  MOVWF  04
0946:  MOVF   3C,W
0947:  MOVWF  05
0948:  ADDFSR 02,FSR0
0949:  MOVLW  30
094A:  ADDWF  00,W
094B:  MOVWF  3D
094C:  MOVF   3D,W
094D:  MOVLP  00
094E:  MOVLB  00
094F:  CALL   02D
0950:  MOVLP  08
....................     putc(pDataP[Min]+48); 
0951:  MOVLB  01
0952:  MOVF   3B,W
0953:  MOVWF  04
0954:  MOVF   3C,W
0955:  MOVWF  05
0956:  ADDFSR 03,FSR0
0957:  MOVLW  30
0958:  ADDWF  00,W
0959:  MOVWF  3D
095A:  MOVF   3D,W
095B:  MOVLP  00
095C:  MOVLB  00
095D:  CALL   02D
095E:  MOVLP  08
....................     putc(58); 
095F:  MOVLW  3A
0960:  MOVLP  00
0961:  CALL   02D
0962:  MOVLP  08
....................     putc(pDataP[TenSec]+48); 
0963:  MOVLB  01
0964:  MOVF   3B,W
0965:  MOVWF  04
0966:  MOVF   3C,W
0967:  MOVWF  05
0968:  ADDFSR 00,FSR0
0969:  MOVLW  30
096A:  ADDWF  00,W
096B:  MOVWF  3D
096C:  MOVF   3D,W
096D:  MOVLP  00
096E:  MOVLB  00
096F:  CALL   02D
0970:  MOVLP  08
....................     putc(pDataP[Sec]+48); 
0971:  MOVLB  01
0972:  MOVF   3B,W
0973:  MOVWF  04
0974:  MOVF   3C,W
0975:  MOVWF  05
0976:  ADDFSR 01,FSR0
0977:  MOVLW  30
0978:  ADDWF  00,W
0979:  MOVWF  3D
097A:  MOVF   3D,W
097B:  MOVLP  00
097C:  MOVLB  00
097D:  CALL   02D
097E:  MOVLP  08
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Print_Data(uint8 *pDataP) 
.................... { 
....................     DS_Read_Data(pDataP); 
....................  
.................... //    printf("\n\r%d%d/%d%d/20%d%d  ",pDataP[TenDate],pDataP[Date], 
.................... //                           pDataP[TenMonth],pDataP[Month], 
.................... //                           pDataP[TenYear],pDataP[Year]); 
.................... //    switch(pDataP[Day]) 
.................... //    { 
.................... //        case Monday : 
.................... //            printf("Mo"); 
.................... //            break; 
.................... //        case Tuesday : 
.................... //            printf("Tu"); 
.................... //            break; 
.................... //        case Wednesday : 
.................... //            printf("We"); 
.................... //            break; 
.................... //        case Thursday : 
.................... //            printf("Th"); 
.................... //            break; 
.................... //        case Friday : 
.................... //            printf("Fr"); 
.................... //            break; 
.................... //        case Saturday : 
.................... //            printf("Sa"); 
.................... //            break; 
.................... //        case Sunday : 
.................... //            printf("Su"); 
.................... //            break; 
.................... //        default: 
.................... //            printf("XX"); 
.................... //            break; 
.................... //    } 
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Read_Clock(uint8 *pDataP) 
.................... { 
....................     uint8 ClockBuff[3]; 
....................  
....................     DS_Reade_Pointer(0,ClockBuff,3); 
*
07B8:  MOVLB  01
07B9:  CLRF   43
07BA:  MOVLW  20
07BB:  MOVWF  45
07BC:  MOVLW  70
07BD:  MOVWF  44
07BE:  MOVLW  03
07BF:  MOVWF  46
07C0:  MOVLB  00
07C1:  CALL   262
....................  
....................     pDataP[Sec]     = (ClockBuff[0] & Sec_Mask); 
07C2:  MOVLB  01
07C3:  MOVF   3E,W
07C4:  MOVWF  04
07C5:  MOVF   3F,W
07C6:  MOVWF  05
07C7:  MOVF   40,W
07C8:  ANDLW  0F
07C9:  MOVWI  W,[FSR0+01]
....................     pDataP[TenSec]  = ((ClockBuff[0] & TenSec_Mask)>>4); 
07CA:  MOVF   3E,W
07CB:  MOVWF  04
07CC:  MOVF   3F,W
07CD:  MOVWF  05
07CE:  MOVF   40,W
07CF:  ANDLW  70
07D0:  MOVWF  77
07D1:  SWAPF  77,F
07D2:  MOVLW  0F
07D3:  ANDWF  77,F
07D4:  MOVF   77,W
07D5:  MOVWI  W,[FSR0+00]
....................     pDataP[Min]     = (ClockBuff[1] & Min_Mask); 
07D6:  MOVF   3E,W
07D7:  MOVWF  04
07D8:  MOVF   3F,W
07D9:  MOVWF  05
07DA:  MOVF   41,W
07DB:  ANDLW  0F
07DC:  MOVWI  W,[FSR0+03]
....................     pDataP[TenMin]  = ((ClockBuff[1] & TenMin_Mask)>>4); 
07DD:  MOVF   3E,W
07DE:  MOVWF  04
07DF:  MOVF   3F,W
07E0:  MOVWF  05
07E1:  MOVF   41,W
07E2:  ANDLW  70
07E3:  MOVWF  77
07E4:  SWAPF  77,F
07E5:  MOVLW  0F
07E6:  ANDWF  77,F
07E7:  MOVF   77,W
07E8:  MOVWI  W,[FSR0+02]
....................     pDataP[Hour]    = (ClockBuff[2] & Hour_Mask); 
07E9:  MOVF   3E,W
07EA:  MOVWF  04
07EB:  MOVF   3F,W
07EC:  MOVWF  05
07ED:  MOVF   42,W
07EE:  ANDLW  0F
07EF:  MOVWI  W,[FSR0+05]
....................     pDataP[TenHour] = ((ClockBuff[2] & TenHour_Mask)>>4); 
07F0:  MOVF   3E,W
07F1:  MOVWF  04
07F2:  MOVF   3F,W
07F3:  MOVWF  05
07F4:  MOVF   42,W
07F5:  ANDLW  30
07F6:  MOVWF  77
07F7:  SWAPF  77,F
07F8:  MOVLW  0F
07F9:  ANDWF  77,F
07FA:  MOVF   77,W
07FB:  MOVWI  W,[FSR0+04]
07FC:  MOVLB  00
07FD:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //this whil write on the addres of the clock 
.................... void DS_Read_Data(uint8 *pDataP) 
.................... { 
....................     uint8 ClockBuff[4]; 
....................  
....................     DS_Reade_Pointer(3,ClockBuff,4); 
....................  
....................     pDataP[Day]     = (ClockBuff[1] & Day_Mask); 
....................  
....................     pDataP[Date]        = (uint8)( ClockBuff[1] & Date_Mask); 
....................     pDataP[TenDate]     = (uint8)((ClockBuff[1] & TenDate_Mask)>>4); 
....................     pDataP[Month]       = (uint8)( ClockBuff[2] & Month_Mask); 
....................     pDataP[TenMonth]    = (uint8)((ClockBuff[2] & TenMonth_Mask)>>4); 
....................     pDataP[Year]        = (uint8)( ClockBuff[3] & Year_Mask); 
....................     pDataP[TenYear]     = (uint8)((ClockBuff[3] & TenYear_Mask)>>4); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Write(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP) 
*
0225:  MOVLW  01
0226:  MOVLB  01
0227:  MOVWF  3F
.................... { 
....................     uint8 u8ByteCountL=1; 
....................     i2c_start(); 
0228:  MOVLB  04
0229:  BSF    16.0
022A:  BTFSC  16.0
022B:  GOTO   22A
....................     i2c_write( DS3231_WriteX ); 
022C:  MOVLW  D0
022D:  MOVLB  01
022E:  MOVWF  4C
022F:  MOVLB  00
0230:  CALL   210
....................  
....................     i2c_write(u8AddresP); 
0231:  MOVLB  01
0232:  MOVF   3B,W
0233:  MOVWF  4C
0234:  MOVLB  00
0235:  CALL   210
....................  
....................     for( u8ByteCountL=1; u8ByteCountL <= u8NumberOfBytesP; u8ByteCountL++ ) 
0236:  MOVLW  01
0237:  MOVLB  01
0238:  MOVWF  3F
0239:  MOVF   3F,W
023A:  SUBWF  3E,W
023B:  BTFSS  03.0
023C:  GOTO   24C
....................     { 
....................         i2c_write(pDataP[u8ByteCountL-1]); 
023D:  MOVLW  01
023E:  SUBWF  3F,W
023F:  ADDWF  3C,W
0240:  MOVWF  04
0241:  MOVLW  00
0242:  ADDWFC 3D,W
0243:  MOVWF  05
0244:  MOVF   00,W
0245:  MOVWF  40
0246:  MOVWF  4C
0247:  MOVLB  00
0248:  CALL   210
0249:  MOVLB  01
024A:  INCF   3F,F
024B:  GOTO   239
....................     } 
....................  
....................     i2c_stop();         // Restart 
024C:  MOVLB  04
024D:  BSF    16.2
024E:  BTFSC  16.2
024F:  GOTO   24E
0250:  MOVLB  00
0251:  RETURN
.................... }/////////////////////////////////////////////////////////////////////////////// 
.................... uint8 DS_Reade_Pointer(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP) 
*
0262:  MOVLW  01
0263:  MOVLB  01
0264:  MOVWF  47
.................... { 
....................     uint8 u8ByteCountL=1; 
....................     uint8 pAckL[3]; 
....................  
....................     i2c_start(); 
0265:  MOVLB  04
0266:  BSF    16.0
0267:  BTFSC  16.0
0268:  GOTO   267
....................     pAckL[0] = i2c_write( DS3231_WriteX ); 
0269:  MOVLW  D0
026A:  MOVLB  01
026B:  MOVWF  4C
026C:  MOVLB  00
026D:  CALL   210
026E:  MOVF   78,W
026F:  MOVLB  01
0270:  MOVWF  48
....................     pAckL[1] = i2c_write( u8AddresP ); 
0271:  MOVF   43,W
0272:  MOVWF  4C
0273:  MOVLB  00
0274:  CALL   210
0275:  MOVF   78,W
0276:  MOVLB  01
0277:  MOVWF  49
....................     pAckL[1] <<= 1; 
0278:  BCF    03.0
0279:  RLF    49,F
....................     i2c_start(); 
027A:  MOVLB  04
027B:  BSF    16.1
027C:  BTFSC  16.1
027D:  GOTO   27C
....................     pAckL[2] = i2c_write( DS3231_ReadX ); 
027E:  MOVLW  D1
027F:  MOVLB  01
0280:  MOVWF  4C
0281:  MOVLB  00
0282:  CALL   210
0283:  MOVF   78,W
0284:  MOVLB  01
0285:  MOVWF  4A
....................     pAckL[2] <<= 2; 
0286:  RLF    4A,F
0287:  RLF    4A,F
0288:  MOVLW  FC
0289:  ANDWF  4A,F
....................  
....................     for( u8ByteCountL=1; u8ByteCountL < u8NumberOfBytesP; u8ByteCountL++ ) 
028A:  MOVLW  01
028B:  MOVWF  47
028C:  MOVF   46,W
028D:  SUBWF  47,W
028E:  BTFSC  03.0
028F:  GOTO   2A0
....................     { 
....................         pDataP[u8ByteCountL-1] = i2c_read(TRUE);  // Data to device 
0290:  MOVLW  01
0291:  SUBWF  47,W
0292:  ADDWF  44,W
0293:  MOVWF  04
0294:  MOVLW  00
0295:  ADDWFC 45,W
0296:  MOVWF  05
0297:  MOVLW  01
0298:  MOVWF  77
0299:  MOVLB  00
029A:  CALL   252
029B:  MOVF   78,W
029C:  MOVWF  00
029D:  MOVLB  01
029E:  INCF   47,F
029F:  GOTO   28C
....................     } 
....................  
....................     pDataP[u8NumberOfBytesP-1] = i2c_read(FALSE); 
02A0:  MOVLW  01
02A1:  SUBWF  46,W
02A2:  ADDWF  44,W
02A3:  MOVWF  04
02A4:  MOVLW  00
02A5:  ADDWFC 45,W
02A6:  MOVWF  05
02A7:  CLRF   77
02A8:  MOVLB  00
02A9:  CALL   252
02AA:  MOVF   78,W
02AB:  MOVWF  00
....................     i2c_stop();         // Restart 
02AC:  MOVLB  04
02AD:  BSF    16.2
02AE:  BTFSC  16.2
02AF:  GOTO   2AE
....................  
....................     return ( pAckL[0] | pAckL[1] | pAckL[2] ); 
02B0:  MOVLB  01
02B1:  MOVF   48,W
02B2:  IORWF  49,W
02B3:  IORWF  4A,W
02B4:  MOVWF  78
02B5:  MOVLB  00
02B6:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint8 DS_Write_Test(unsigned char rtcreg, unsigned int8 rtc_data) 
.................... { 
.................... //Example    ds1307_write_test(1,0b10000100); 
....................     short ick[4]= {1,1,1,1}; 
*
02FA:  MOVLW  0F
02FB:  MOVWF  34
....................     i2c_start(); 
02FC:  MOVLB  04
02FD:  BSF    16.0
02FE:  BTFSC  16.0
02FF:  GOTO   2FE
....................     ick[0] = i2c_write(0xd0); 
0300:  MOVLW  D0
0301:  MOVLB  01
0302:  MOVWF  4C
0303:  MOVLB  00
0304:  CALL   210
0305:  MOVF   78,W
0306:  MOVLB  01
0307:  BCF    34.0
0308:  BTFSC  78.0
0309:  BSF    34.0
....................     ick[1] = i2c_write(rtcreg); 
030A:  MOVF   32,W
030B:  MOVWF  4C
030C:  MOVLB  00
030D:  CALL   210
030E:  MOVF   78,W
030F:  MOVLB  01
0310:  BCF    34.1
0311:  BTFSC  78.0
0312:  BSF    34.1
....................     ick[2] = i2c_write(rtc_data); 
0313:  MOVF   33,W
0314:  MOVWF  4C
0315:  MOVLB  00
0316:  CALL   210
0317:  MOVF   78,W
0318:  MOVLB  01
0319:  BCF    34.2
031A:  BTFSC  78.0
031B:  BSF    34.2
....................     i2c_stop(); 
031C:  MOVLB  04
031D:  BSF    16.2
031E:  BTFSC  16.2
031F:  GOTO   31E
....................     if(!(ick[0]||ick[1]||ick[2])) 
0320:  MOVLB  01
0321:  BTFSC  34.0
0322:  GOTO   339
0323:  BTFSC  34.1
0324:  GOTO   339
0325:  BTFSC  34.2
0326:  GOTO   339
....................     {/*lcd_gotoxy(17,1);*/ 
....................         putc(13);putc('D');putc('S');putc(' ');putc('O');putc('k'); 
0327:  MOVLW  0D
0328:  MOVLB  00
0329:  CALL   02D
032A:  MOVLW  44
032B:  CALL   02D
032C:  MOVLW  53
032D:  CALL   02D
032E:  MOVLW  20
032F:  CALL   02D
0330:  MOVLW  4F
0331:  CALL   02D
0332:  MOVLW  6B
0333:  CALL   02D
....................         //printf("\r\nCommunication is OK"); 
....................         return 1; 
0334:  MOVLW  01
0335:  MOVWF  78
0336:  GOTO   34A
....................     } 
0337:  GOTO   34A
0338:  MOVLB  01
....................     else  
....................     {/*lcd_gotoxy(17,1);*/ 
....................         putc(13);putc('D');putc('S');putc(' ');putc('N');putc('O');putc('k'); 
0339:  MOVLW  0D
033A:  MOVLB  00
033B:  CALL   02D
033C:  MOVLW  44
033D:  CALL   02D
033E:  MOVLW  53
033F:  CALL   02D
0340:  MOVLW  20
0341:  CALL   02D
0342:  MOVLW  4E
0343:  CALL   02D
0344:  MOVLW  4F
0345:  CALL   02D
0346:  MOVLW  6B
0347:  CALL   02D
....................         //printf("\r\nCommunication is NOT ok"); 
....................         return 0; 
0348:  MOVLW  00
0349:  MOVWF  78
....................     } 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void SetSnoozeDelay(char * cMsgClockP) 
.................... { 
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('O');putc('l');putc('d'); 
....................     putc(10); 
....................     putc(13); 
....................     DS_Print_Clock(u8SnoozeDelay); 
.................... #endif 
....................      
.................... 	DS_String_To_Massiv_Clock(u8SnoozeDelay,cMsgClockP); 
....................      
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('N');putc('e');putc('w'); 
.................... 	putc(10); 
....................     putc(13); 
....................     DS_Print_Clock(u8SnoozeDelay); 
.................... #endif 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void SetInitialDelay(char * cMsgClockP) 
.................... { 
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('O');putc('l');putc('d'); 
.................... 	putc(10); 
....................     putc(13); 
....................     DS_Print_Clock(u8InitialDelay); 
.................... #endif 
....................      
.................... 	DS_String_To_Massiv_Clock(u8InitialDelay,cMsgClockP); 
....................      
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('N');putc('e');putc('w'); 
....................     putc(10); 
....................     putc(13); 
....................     DS_Print_Clock(u8InitialDelay); 
.................... #endif 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DecodeClock(char * cMsgClockP) 
.................... { 
....................     unsigned int8 u8ClockSetL[6]; 
.................... 	 
....................     DS_String_To_Massiv_Clock(&u8ClockSetL,cMsgClockP); 
....................     DS_Init_Clock(1, u8ClockSetL); 
....................     putc(10); 
....................     putc(13); 
....................     DS_Print_Clock(u8ClockSetL); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_String_To_Massiv_Clock(uint8 * u8ClockSetP, char * cMsgClockP) 
.................... { 
.................... //   unsigned int8 u8ClockSetL[13]; 
....................     u8ClockSetP[Sec]      = (cMsgClockP[7] - 48); 
....................     u8ClockSetP[TenSec]   = (cMsgClockP[6] - 48); 
....................  
....................     u8ClockSetP[Min]      = (cMsgClockP[4] - 48); 
....................     u8ClockSetP[TenMin]   = (cMsgClockP[3] - 48); 
....................  
....................     u8ClockSetP[Hour]     = (cMsgClockP[1] - 48); 
....................     u8ClockSetP[TenHour]  = (cMsgClockP[0] - 48); 
....................  
.................... //    printf("\n\r%d%d:%d%d:%d%d string",u8ClockSetP[TenHour],u8ClockSetP[Hour], 
.................... //                                u8ClockSetP[TenMin], u8ClockSetP[Min], 
.................... //                                u8ClockSetP[TenSec], u8ClockSetP[Sec]); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DecodeData(char * cMsgClock) 
.................... { 
....................     unsigned int8 u8DataSetL[6]; 
....................     DS_String_To_Massiv_Data(&u8DataSetL,cMsgClock); 
....................  
....................     DS_Init_Data(1, u8DataSetL); 
.................... //    printf("\n\r"); 
.................... //    DS_Print_Data(u8DataSetL); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_String_To_Massiv_Data(uint8 * u8DateSetP, char * cMsgClock) 
.................... { 
.................... //    unsigned int8 u8ClockSetL[13]; 
....................     u8DateSetP[TenDate]     = (cMsgClock[0] - 48); 
....................     u8DateSetP[Date]        = (cMsgClock[1] - 48); 
....................  
....................     u8DateSetP[TenMonth]    = (cMsgClock[3] - 48); 
....................     u8DateSetP[Month]       = (cMsgClock[4] - 48); 
....................  
....................     u8DateSetP[TenYear]     = (cMsgClock[8] - 48); 
....................     u8DateSetP[Year]        = (cMsgClock[9] - 48); 
.................... //    printf("\n\r%u%u/%u%u/%u%u string", 
.................... //                                u8DateSetP[TenDate],u8DateSetP[Date], 
.................... //                                u8DateSetP[TenMonth], u8DateSetP[Month], 
.................... //                                u8DateSetP[TenYear], u8DateSetP[Year]); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "DS13XX.c" 
....................  
.................... #include "DS13XX.h" 
.................... #ifndef DS13XX 
.................... #define	DS13XX 
....................  
.................... void DS_Print_Clock_3by(uint8 *pDataP, uint8 u8NewLineP); 
.................... void DS_Read_Clock_3by(uint8 *pDataP); 
.................... void DS_String_To_Massiv_Clock_3by(uint8 * u8ClockSetP, char * cMsgClockP); 
.................... void DS_Init_Clock_3by(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DecodeInitPrintClock_3by(char * cMsgClockP); 
....................  
.................... void SetSnoozeDelay_3by(char * cMsgClockP); 
.................... void SetInitialDelay_3by(char * cMsgClockP); 
....................  
.................... void AddTimeToAlarm_3by(void); 
....................  
.................... #endif 
....................  
.................... #include "DS1307.h" 
....................  
....................  
....................  
.................... #ifndef DS 
.................... #define	DS 
....................  
.................... #include "ClockCalculationTransformation.c" 
....................  
.................... //============================================================================== 
.................... // PRIVATE MACROS 
.................... //============================================================================== 
.................... #define     DS3231_WriteX    0xD0 
.................... #define     DS3231_ReadX     0xD1 
....................  
.................... /*          DaynamicFlags       */ 
....................  
.................... #define     SetSnoozeDelayFlagMask      0x0001    //0b00000000 00000001 
.................... #define     SetInitialDelayFlagMask     0x0002    //0b00000000 00000010 
.................... #define     EffectIncrementFlagMask     0x0004    //0b00000000 00000100 
.................... #define     AddSnoozeDelayFlagMask      0x0008    //0b00000000 00001000 
.................... #define     SetAlarmFlagMask            0x0010    //0b00000000 00010000 
.................... #define     SetClockFlagMask            0x0020    //0b00000000 00100000 
.................... #define     OneSecondTaskFlagMask       0x0040    //0b00000000 01000000 
.................... #define     ReadeClockFlagMask          0x0080    //0b00000000 10000000 
.................... //u16ByteFlags2 
.................... #define     SleepDelayFlagMask          0x0001    //0b00000001 00000000 
....................  
.................... /*          StaticFlags       */ 
.................... #define     DebugPrintFlagMask          0x01    //0b00000001 
.................... #define     SleepFlagMask               0x02    //0b00000010 
.................... //TBD 
.................... //#define     u1StartFlagGlowAltL         0x04    //0b00000100 
....................  
.................... #define     DebugPrintClock     0x01 
....................  
.................... #Bit    DS_Power_Pin_TRIS   =   TRISC.5 
.................... #Bit    DS_Power_Pin        =   PORTC.5 
....................  
.................... void ds1307_write_test(unsigned char rtcreg, unsigned int8 rtc_data); 
.................... uint8 DS_Write_Test(unsigned char rtcreg, unsigned int8 rtc_data); 
....................  
.................... void min_inc(void); 
.................... void hour_inc(void); 
....................  
.................... void DS_Task(void); 
....................  
.................... void DS_Init(void); 
.................... void DS_Init_Clock(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_Data(uint8 u8FlagInitP, uint8 *pDataP); 
.................... void DS_Init_OutClock(void); 
....................  
.................... void DS_Read_Clock(uint8 *pDataP); 
.................... void DS_Read_Data(uint8 *pDataP); 
....................  
.................... void DS_Print_Clock(uint8 *pDataP); 
.................... void DS_Print_Data(uint8 *pDataP); 
....................  
.................... void DS_Write(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
.................... void DS_Read(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... void DS_String_To_Massiv_Clock(uint8 * u8ClockSetP, char * cMsgClock); 
.................... void DS_String_To_Massiv_Data(uint8 * u8DateSetP, char * cMsgClock); 
....................  
.................... void SetSnoozeDelay(char * cMsgClockP); 
.................... void SetInitialDelay(char * cMsgClockP); 
....................  
.................... void DecodeClock(char * cMsgClock); 
.................... void DecodeData(char * cMsgClock); 
....................  
.................... uint8 DS_Reade_Pointer(uint8 u8AddresP, uint8 *pDataP, uint8 u8NumberOfBytesP); 
....................  
.................... uint8 Comppare_Time(uint8 *pDataP, uint8 *pAlarmP); 
.................... //uint8 Check_Sequences(uint8 *pDataP); 
.................... void Menage_Alarma(uint8 *pDataP); 
.................... void SetAlarm(void); 
.................... void AddTimeToAlarm(void); 
....................  
.................... //unsigned int8 rtensec; 
.................... //unsigned int8 rsec; 
.................... //unsigned int8 rtenmin; 
.................... //unsigned int8 rmin; 
.................... //unsigned int8 rtenhour; 
.................... //unsigned int8 rhour; 
.................... //unsigned int8 rday; 
.................... //unsigned int8 rtendate; 
.................... //unsigned int8 rdate; 
.................... //unsigned int8 rmonth; 
.................... //unsigned int8 rtenmonth; 
.................... //unsigned int8 rtenyear; 
.................... //unsigned int8 ryear; 
....................  
.................... unsigned int16 u16TaskTimeCounterL = 0; 
....................  
.................... unsigned int8 u8Alarm[6] = {5,9,5,9,0,0}; 
....................  
.................... unsigned int8 u8InitialDelay[6] = {0,0,3,0,0,4}; 
....................  
.................... unsigned int8 u8SnoozeDelay[6] = {5,9,5,9,2,3}; 
....................  
....................  
.................... //unsigned int8 u8ReadeClockFlag = 0; 
.................... //unsigned int8 u8SetDataFlag = 0; 
.................... //unsigned int8 u8DebugPrintFlag = 0; 
....................  
.................... //unsigned int8 u8SetNapDelayFlag = 0; 
....................  
.................... unsigned int16 u16ByteFlags = 0; 
.................... unsigned int16 u16ByteFlags2 = 0; 
.................... unsigned int8 u8StaicByteFlags = (SleepFlagMask || DebugPrintFlagMask); 
....................  
.................... #define TenSec      0 
.................... #define Sec         1 
.................... #define TenMin      2 
.................... #define Min         3 
.................... #define TenHour     4 
.................... #define Hour        5 
....................  
.................... #define AlarmTenSec      0 
.................... #define AlarmSec         1 
.................... #define AlarmTenMin      2 
.................... #define AlarmMin         3 
.................... #define AlarmTenHour     4 
.................... #define AlarmHour        5 
....................  
.................... #define Day         6 
....................  
.................... #define TenDate     0 
.................... #define Date        1 
.................... #define Month       2 
.................... #define TenMonth    3 
.................... #define TenYear     4 
.................... #define Year        5 
....................  
.................... //TBD 0b - 0x 
.................... #define Sec_Mask             0b00001111 
.................... #define TenSec_Mask          0b01110000 
.................... #define Min_Mask             0b00001111 
.................... #define TenMin_Mask          0b01110000 
.................... #define Hour_Mask            0b00001111 
.................... #define TenHour_Mask         0b00110000 
....................  
.................... #define Day_Mask             0b00000111 
.................... #define Date_Mask            0b00001111 
.................... #define TenDate_Mask         0b00110000 
.................... #define Month_Mask           0b00001111 
.................... #define TenMonth_Mask        0b00010000 
.................... #define Year_Mask            0b00001111 
.................... #define TenYear_Mask         0b11110000 
....................  
.................... #define Monday      1 
.................... #define Tuesday     2 
.................... #define Wednesday   3 
.................... #define Thursday    4 
.................... #define Friday      5 
.................... #define Saturday    6 
.................... #define Sunday      7 
....................  
.................... #endif	/* DS*/ 
....................  
.................... #include "ClockCalculationTransformation.h" 
....................  
.................... #ifndef ClockCalculationTransformation 
.................... #define ClockCalculationTransformation 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //CCT - Clock Calculation Transformation 
.................... #define TenSecCCT      4 
.................... #define SecCCT         5 
.................... #define TenMinCCT      2 
.................... #define MinCCT         3 
.................... #define TenHourCCT     0 
.................... #define HourCCT        1 
....................  
.................... #define MasHour        0 
.................... #define MasMin         1 
.................... #define MasSec         2 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void TestClockInputs(uint8 *pDataP); 
.................... #ifndef DS 
.................... void DS_Print_Clock(uint8 *pDataP); 
.................... #endif 
.................... void DS_Print_Clock_Mas(uint8 *pDataP, uint8 u8NewLineP); 
.................... void DigitsToInt (uint8 *u8InputP, uint8 *u8OutputP); 
.................... void IntToDigits (uint8 *u8InputP, uint8 *u8OutputP); 
.................... void AddTimeToClock(uint8 *u8ClockP, uint8 u8AddedTimeP); 
.................... void DigitsTest (void); 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #endif //#define ClockCalculationTransformation 
....................  
....................  
.................... //3by - 3 bytes 
.................... //is in format {23,59,59} 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Print_Clock_3by(uint8 *pDataP, uint8 u8NewLineP) 
.................... { 
.................... //TBD Print_Data 
.................... //   (day / 10)   + 48);    // Print tens digit of day variable 
.................... //   (day % 10)   + 48);    // Print oness digit of day variable 
.................... //   (month / 10) + 48); 
.................... //   (month % 10) + 48); 
.................... //   Lcd_Chr(1,15,  year        + 49);    // Print year vaiable + 1 (start from year 2011) 
....................     if(0 != u8NewLineP) 
*
0401:  MOVLB  01
0402:  MOVF   3D,F
0403:  BTFSC  03.2
0404:  GOTO   40B
....................     { 
....................        putc(10); 
0405:  MOVLW  0A
0406:  MOVLB  00
0407:  CALL   02D
....................        putc(13); 
0408:  MOVLW  0D
0409:  CALL   02D
040A:  MOVLB  01
....................     } 
....................     putc((pDataP[MasHour] / 10) + 48); 
040B:  MOVF   3B,W
040C:  MOVWF  04
040D:  MOVF   3C,W
040E:  MOVWF  05
040F:  ADDFSR 00,FSR0
0410:  MOVF   00,W
0411:  MOVWF  3F
0412:  MOVLW  0A
0413:  MOVWF  40
0414:  MOVLB  00
0415:  CALL   3EA
0416:  MOVLW  30
0417:  ADDWF  78,W
0418:  MOVLB  01
0419:  MOVWF  3E
041A:  MOVF   3E,W
041B:  MOVLB  00
041C:  CALL   02D
....................     putc((pDataP[MasHour] % 10) + 48); 
041D:  MOVLB  01
041E:  MOVF   3B,W
041F:  MOVWF  04
0420:  MOVF   3C,W
0421:  MOVWF  05
0422:  ADDFSR 00,FSR0
0423:  MOVF   00,W
0424:  MOVWF  3F
0425:  MOVLW  0A
0426:  MOVWF  40
0427:  MOVLB  00
0428:  CALL   3EA
0429:  MOVLW  30
042A:  ADDWF  77,W
042B:  MOVLB  01
042C:  MOVWF  3E
042D:  MOVF   3E,W
042E:  MOVLB  00
042F:  CALL   02D
....................     putc(':'); 
0430:  MOVLW  3A
0431:  CALL   02D
....................     putc((pDataP[MasMin]  / 10) + 48); 
0432:  MOVLB  01
0433:  MOVF   3B,W
0434:  MOVWF  04
0435:  MOVF   3C,W
0436:  MOVWF  05
0437:  ADDFSR 01,FSR0
0438:  MOVF   00,W
0439:  MOVWF  3F
043A:  MOVLW  0A
043B:  MOVWF  40
043C:  MOVLB  00
043D:  CALL   3EA
043E:  MOVLW  30
043F:  ADDWF  78,W
0440:  MOVLB  01
0441:  MOVWF  3E
0442:  MOVF   3E,W
0443:  MOVLB  00
0444:  CALL   02D
....................     putc((pDataP[MasMin]  % 10) + 48); 
0445:  MOVLB  01
0446:  MOVF   3B,W
0447:  MOVWF  04
0448:  MOVF   3C,W
0449:  MOVWF  05
044A:  ADDFSR 01,FSR0
044B:  MOVF   00,W
044C:  MOVWF  3F
044D:  MOVLW  0A
044E:  MOVWF  40
044F:  MOVLB  00
0450:  CALL   3EA
0451:  MOVLW  30
0452:  ADDWF  77,W
0453:  MOVLB  01
0454:  MOVWF  3E
0455:  MOVF   3E,W
0456:  MOVLB  00
0457:  CALL   02D
....................     putc(':'); 
0458:  MOVLW  3A
0459:  CALL   02D
....................     putc((pDataP[MasSec]  / 10) + 48); 
045A:  MOVLB  01
045B:  MOVF   3B,W
045C:  MOVWF  04
045D:  MOVF   3C,W
045E:  MOVWF  05
045F:  ADDFSR 02,FSR0
0460:  MOVF   00,W
0461:  MOVWF  3F
0462:  MOVLW  0A
0463:  MOVWF  40
0464:  MOVLB  00
0465:  CALL   3EA
0466:  MOVLW  30
0467:  ADDWF  78,W
0468:  MOVLB  01
0469:  MOVWF  3E
046A:  MOVF   3E,W
046B:  MOVLB  00
046C:  CALL   02D
....................     putc((pDataP[MasSec]  % 10) + 48); 
046D:  MOVLB  01
046E:  MOVF   3B,W
046F:  MOVWF  04
0470:  MOVF   3C,W
0471:  MOVWF  05
0472:  ADDFSR 02,FSR0
0473:  MOVF   00,W
0474:  MOVWF  3F
0475:  MOVLW  0A
0476:  MOVWF  40
0477:  MOVLB  00
0478:  CALL   3EA
0479:  MOVLW  30
047A:  ADDWF  77,W
047B:  MOVLB  01
047C:  MOVWF  3E
047D:  MOVF   3E,W
047E:  MOVLB  00
047F:  CALL   02D
0480:  RETURN
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DS_Read_Clock_3by(uint8 *pDataP) 
.................... { 
....................     uint8 ClockBuff[3]; 
....................  
....................     DS_Reade_Pointer(0,ClockBuff,3); 
*
0760:  MOVLB  01
0761:  CLRF   43
0762:  MOVLW  20
0763:  MOVWF  45
0764:  MOVLW  5D
0765:  MOVWF  44
0766:  MOVLW  03
0767:  MOVWF  46
0768:  MOVLB  00
0769:  CALL   262
.................... //TBD rede Data 
....................     //  year     =   (day & 0xC0) >> 6;                             // Transform year 
....................     //  day      =  ((day & 0x30) >> 4)*10    + (day & 0x0F);       // Transform day 
....................     //  month    =  ((month & 0x10)  >> 4)*10 + (month & 0x0F);     // Transform month 
....................      
....................     pDataP[MasSec]  = ((ClockBuff[0] & TenSec_Mask)  >> 4)*10 + (ClockBuff[0] & Sec_Mask); 
076A:  MOVLB  01
076B:  MOVF   2B,W
076C:  MOVWF  04
076D:  MOVF   2C,W
076E:  MOVWF  05
076F:  ADDFSR 02,FSR0
0770:  MOVF   2D,W
0771:  ANDLW  70
0772:  MOVWF  77
0773:  SWAPF  77,F
0774:  MOVLW  0F
0775:  ANDWF  77,F
0776:  MOVF   77,W
0777:  MOVWF  33
0778:  MOVWF  3C
0779:  MOVLW  0A
077A:  MOVWF  3D
077B:  MOVLB  00
077C:  CALL   481
077D:  MOVF   78,W
077E:  MOVLB  01
077F:  MOVWF  32
0780:  MOVF   2D,W
0781:  ANDLW  0F
0782:  ADDWF  32,W
0783:  MOVWF  00
....................     pDataP[MasMin]  = ((ClockBuff[1] & TenMin_Mask)  >> 4)*10 + (ClockBuff[1] & Min_Mask); 
0784:  MOVF   2B,W
0785:  MOVWF  04
0786:  MOVF   2C,W
0787:  MOVWF  05
0788:  ADDFSR 01,FSR0
0789:  MOVF   2E,W
078A:  ANDLW  70
078B:  MOVWF  77
078C:  SWAPF  77,F
078D:  MOVLW  0F
078E:  ANDWF  77,F
078F:  MOVF   77,W
0790:  MOVWF  33
0791:  MOVWF  3C
0792:  MOVLW  0A
0793:  MOVWF  3D
0794:  MOVLB  00
0795:  CALL   481
0796:  MOVF   78,W
0797:  MOVLB  01
0798:  MOVWF  32
0799:  MOVF   2E,W
079A:  ANDLW  0F
079B:  ADDWF  32,W
079C:  MOVWF  00
....................     pDataP[MasHour] = ((ClockBuff[2] & TenHour_Mask) >> 4)*10 + (ClockBuff[2] & Hour_Mask); 
079D:  MOVF   2B,W
079E:  MOVWF  04
079F:  MOVF   2C,W
07A0:  MOVWF  05
07A1:  ADDFSR 00,FSR0
07A2:  MOVF   2F,W
07A3:  ANDLW  30
07A4:  MOVWF  77
07A5:  SWAPF  77,F
07A6:  MOVLW  0F
07A7:  ANDWF  77,F
07A8:  MOVF   77,W
07A9:  MOVWF  33
07AA:  MOVWF  3C
07AB:  MOVLW  0A
07AC:  MOVWF  3D
07AD:  MOVLB  00
07AE:  CALL   481
07AF:  MOVF   78,W
07B0:  MOVLB  01
07B1:  MOVWF  32
07B2:  MOVF   2F,W
07B3:  ANDLW  0F
07B4:  ADDWF  32,W
07B5:  MOVWF  00
07B6:  MOVLB  00
07B7:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //cMsgClockP - 23:59:56 
.................... void DS_String_To_Massiv_Clock_3by(uint8 * u8ClockSetP, char * cMsgClockP) 
.................... { 
....................     u8ClockSetP[MasSec]  = ((cMsgClockP[6] - 48)*10 + (cMsgClockP[7] - 48)); 
*
04A8:  MOVLW  02
04A9:  MOVLB  01
04AA:  ADDWF  33,W
04AB:  MOVWF  78
04AC:  MOVLW  00
04AD:  ADDWFC 34,W
04AE:  MOVWF  7A
04AF:  MOVF   78,W
04B0:  MOVWF  38
04B1:  MOVF   7A,W
04B2:  MOVWF  39
04B3:  MOVF   35,W
04B4:  MOVWF  04
04B5:  MOVF   36,W
04B6:  MOVWF  05
04B7:  ADDFSR 06,FSR0
04B8:  MOVLW  30
04B9:  SUBWF  00,W
04BA:  MOVWF  3B
04BB:  MOVWF  3C
04BC:  MOVLW  0A
04BD:  MOVWF  3D
04BE:  MOVLB  00
04BF:  CALL   481
04C0:  MOVF   78,W
04C1:  MOVLB  01
04C2:  MOVWF  3A
04C3:  MOVF   35,W
04C4:  MOVWF  04
04C5:  MOVF   36,W
04C6:  MOVWF  05
04C7:  ADDFSR 07,FSR0
04C8:  MOVLW  30
04C9:  SUBWF  00,W
04CA:  ADDWF  3A,W
04CB:  MOVWF  3A
04CC:  MOVF   39,W
04CD:  MOVWF  05
04CE:  MOVF   38,W
04CF:  MOVWF  04
04D0:  MOVF   3A,W
04D1:  MOVWF  00
....................     u8ClockSetP[MasMin]  = ((cMsgClockP[3] - 48)*10 + (cMsgClockP[4] - 48)); 
04D2:  MOVLW  01
04D3:  ADDWF  33,W
04D4:  MOVWF  78
04D5:  MOVLW  00
04D6:  ADDWFC 34,W
04D7:  MOVWF  7A
04D8:  MOVF   78,W
04D9:  MOVWF  38
04DA:  MOVF   7A,W
04DB:  MOVWF  39
04DC:  MOVF   35,W
04DD:  MOVWF  04
04DE:  MOVF   36,W
04DF:  MOVWF  05
04E0:  ADDFSR 03,FSR0
04E1:  MOVLW  30
04E2:  SUBWF  00,W
04E3:  MOVWF  3B
04E4:  MOVWF  3C
04E5:  MOVLW  0A
04E6:  MOVWF  3D
04E7:  MOVLB  00
04E8:  CALL   481
04E9:  MOVF   78,W
04EA:  MOVLB  01
04EB:  MOVWF  3A
04EC:  MOVF   35,W
04ED:  MOVWF  04
04EE:  MOVF   36,W
04EF:  MOVWF  05
04F0:  ADDFSR 04,FSR0
04F1:  MOVLW  30
04F2:  SUBWF  00,W
04F3:  ADDWF  3A,W
04F4:  MOVWF  3A
04F5:  MOVF   39,W
04F6:  MOVWF  05
04F7:  MOVF   38,W
04F8:  MOVWF  04
04F9:  MOVF   3A,W
04FA:  MOVWF  00
....................     u8ClockSetP[MasHour] = ((cMsgClockP[0] - 48)*10 + (cMsgClockP[1] - 48)); 
04FB:  MOVF   33,W
04FC:  MOVWF  78
04FD:  MOVF   34,W
04FE:  MOVWF  7A
04FF:  MOVF   33,W
0500:  MOVWF  38
0501:  MOVF   34,W
0502:  MOVWF  39
0503:  MOVF   35,W
0504:  MOVWF  04
0505:  MOVF   36,W
0506:  MOVWF  05
0507:  ADDFSR 00,FSR0
0508:  MOVLW  30
0509:  SUBWF  00,W
050A:  MOVWF  3B
050B:  MOVWF  3C
050C:  MOVLW  0A
050D:  MOVWF  3D
050E:  MOVLB  00
050F:  CALL   481
0510:  MOVF   78,W
0511:  MOVLB  01
0512:  MOVWF  3A
0513:  MOVF   35,W
0514:  MOVWF  04
0515:  MOVF   36,W
0516:  MOVWF  05
0517:  ADDFSR 01,FSR0
0518:  MOVLW  30
0519:  SUBWF  00,W
051A:  ADDWF  3A,W
051B:  MOVWF  3A
051C:  MOVF   39,W
051D:  MOVWF  05
051E:  MOVF   38,W
051F:  MOVWF  04
0520:  MOVF   3A,W
0521:  MOVWF  00
0522:  MOVLB  00
0523:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void DecodeInitPrintClock_3by(char * cMsgClockP) 
.................... { 
....................     unsigned int8 u8ClockSetL[6]; 
.................... 	 
....................     DS_String_To_Massiv_Clock_3by(&u8ClockSetL,cMsgClockP); 
*
0800:  MOVLW  20
0801:  MOVLB  01
0802:  MOVWF  34
0803:  MOVLW  5D
0804:  MOVWF  33
0805:  MOVF   2C,W
0806:  MOVWF  36
0807:  MOVF   2B,W
0808:  MOVWF  35
0809:  MOVLP  00
080A:  MOVLB  00
080B:  CALL   4A8
080C:  MOVLP  08
....................     DS_Init_Clock_3by(1, u8ClockSetL); 
080D:  MOVLW  01
080E:  MOVLB  01
080F:  MOVWF  33
0810:  MOVLW  20
0811:  MOVWF  35
0812:  MOVLW  5D
0813:  MOVWF  34
....................     DS_Print_Clock_3by(u8ClockSetL,1); 
*
08B4:  MOVLW  20
08B5:  MOVLB  01
08B6:  MOVWF  3C
08B7:  MOVLW  5D
08B8:  MOVWF  3B
08B9:  MOVLW  01
08BA:  MOVWF  3D
08BB:  MOVLP  00
08BC:  MOVLB  00
08BD:  CALL   401
08BE:  MOVLP  08
08BF:  MOVLP  08
08C0:  GOTO   3B6 (RETURN)
....................      
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //pDataP is in format {23,59,59} 
....................    void DS_Init_Clock_3by(uint8 u8FlagInitP, uint8 *pDataP) 
*
0814:  MOVLW  3B
0815:  MOVWF  36
0816:  MOVWF  37
0817:  MOVLW  17
0818:  MOVWF  38
.................... { 
....................  
....................     uint8 u8SecL=59; 
....................     uint8 u8MinL=59; 
....................     uint8 u8HourL=23; 
....................  
....................     if( u8FlagInitP == 1) 
0819:  DECFSZ 33,W
081A:  GOTO   08D
....................     { 
....................         u8SecL  = ((( pDataP[MasSec] / 10 ) << 4 ) & TenSec_Mask ) | (( pDataP[MasSec] % 10 )); 
081B:  MOVF   34,W
081C:  MOVWF  04
081D:  MOVF   35,W
081E:  MOVWF  05
081F:  ADDFSR 02,FSR0
0820:  MOVF   00,W
0821:  MOVWF  3F
0822:  MOVLW  0A
0823:  MOVWF  40
0824:  MOVLP  00
0825:  MOVLB  00
0826:  CALL   3EA
0827:  MOVLP  08
0828:  SWAPF  78,W
0829:  MOVWF  77
082A:  MOVLW  F0
082B:  ANDWF  77,F
082C:  MOVF   77,W
082D:  ANDLW  70
082E:  MOVLB  01
082F:  MOVWF  3A
0830:  MOVF   34,W
0831:  MOVWF  04
0832:  MOVF   35,W
0833:  MOVWF  05
0834:  ADDFSR 02,FSR0
0835:  MOVF   00,W
0836:  MOVWF  3F
0837:  MOVLW  0A
0838:  MOVWF  40
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   3EA
083C:  MOVLP  08
083D:  MOVF   77,W
083E:  MOVLB  01
083F:  IORWF  3A,W
0840:  MOVWF  36
....................         u8MinL  = ((( pDataP[MasMin] / 10 ) << 4 ) & TenMin_Mask ) | (( pDataP[MasMin] % 10 )); 
0841:  MOVF   34,W
0842:  MOVWF  04
0843:  MOVF   35,W
0844:  MOVWF  05
0845:  ADDFSR 01,FSR0
0846:  MOVF   00,W
0847:  MOVWF  3F
0848:  MOVLW  0A
0849:  MOVWF  40
084A:  MOVLP  00
084B:  MOVLB  00
084C:  CALL   3EA
084D:  MOVLP  08
084E:  SWAPF  78,W
084F:  MOVWF  77
0850:  MOVLW  F0
0851:  ANDWF  77,F
0852:  MOVF   77,W
0853:  ANDLW  70
0854:  MOVLB  01
0855:  MOVWF  3A
0856:  MOVF   34,W
0857:  MOVWF  04
0858:  MOVF   35,W
0859:  MOVWF  05
085A:  ADDFSR 01,FSR0
085B:  MOVF   00,W
085C:  MOVWF  3F
085D:  MOVLW  0A
085E:  MOVWF  40
085F:  MOVLP  00
0860:  MOVLB  00
0861:  CALL   3EA
0862:  MOVLP  08
0863:  MOVF   77,W
0864:  MOVLB  01
0865:  IORWF  3A,W
0866:  MOVWF  37
....................         u8HourL = ((( pDataP[MasHour] / 10 ) << 4 ) & TenHour_Mask ) | (( pDataP[MasHour] % 10 )); 
0867:  MOVF   34,W
0868:  MOVWF  04
0869:  MOVF   35,W
086A:  MOVWF  05
086B:  ADDFSR 00,FSR0
086C:  MOVF   00,W
086D:  MOVWF  3F
086E:  MOVLW  0A
086F:  MOVWF  40
0870:  MOVLP  00
0871:  MOVLB  00
0872:  CALL   3EA
0873:  MOVLP  08
0874:  SWAPF  78,W
0875:  MOVWF  77
0876:  MOVLW  F0
0877:  ANDWF  77,F
0878:  MOVF   77,W
0879:  ANDLW  30
087A:  MOVLB  01
087B:  MOVWF  3A
087C:  MOVF   34,W
087D:  MOVWF  04
087E:  MOVF   35,W
087F:  MOVWF  05
0880:  ADDFSR 00,FSR0
0881:  MOVF   00,W
0882:  MOVWF  3F
0883:  MOVLW  0A
0884:  MOVWF  40
0885:  MOVLP  00
0886:  MOVLB  00
0887:  CALL   3EA
0888:  MOVLP  08
0889:  MOVF   77,W
088A:  MOVLB  01
088B:  IORWF  3A,W
088C:  MOVWF  38
....................     } 
....................      
....................     u8SecL &= (~0b10000000);// the oscillator is enabled 
088D:  BCF    36.7
....................  
....................     DS_Write(0,&u8SecL,1); 
088E:  CLRF   3B
088F:  MOVLW  20
0890:  MOVWF  3D
0891:  MOVLW  66
0892:  MOVWF  3C
0893:  MOVLW  01
0894:  MOVWF  3E
0895:  MOVLP  00
0896:  MOVLB  00
0897:  CALL   225
0898:  MOVLP  08
....................     DS_Write(1,&u8MinL,1); 
0899:  MOVLW  01
089A:  MOVLB  01
089B:  MOVWF  3B
089C:  MOVLW  20
089D:  MOVWF  3D
089E:  MOVLW  67
089F:  MOVWF  3C
08A0:  MOVLW  01
08A1:  MOVWF  3E
08A2:  MOVLP  00
08A3:  MOVLB  00
08A4:  CALL   225
08A5:  MOVLP  08
....................     DS_Write(2,&u8HourL,1); 
08A6:  MOVLW  02
08A7:  MOVLB  01
08A8:  MOVWF  3B
08A9:  MOVLW  20
08AA:  MOVWF  3D
08AB:  MOVLW  68
08AC:  MOVWF  3C
08AD:  MOVLW  01
08AE:  MOVWF  3E
08AF:  MOVLP  00
08B0:  MOVLB  00
08B1:  CALL   225
08B2:  MOVLP  08
08B3:  NOP
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void SetSnoozeDelay_3by(char * cMsgClockP) 
.................... { 
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('O');putc('l');putc('d'); 
*
0524:  MOVLW  0D
0525:  CALL   02D
0526:  MOVLW  4F
0527:  CALL   02D
0528:  MOVLW  6C
0529:  CALL   02D
052A:  MOVLW  64
052B:  CALL   02D
....................     DS_Print_Clock_3by(u8SnoozeDelay,1); 
052C:  MOVLW  20
052D:  MOVLB  01
052E:  MOVWF  3C
052F:  MOVLW  25
0530:  MOVWF  3B
0531:  MOVLW  01
0532:  MOVWF  3D
0533:  MOVLB  00
0534:  CALL   401
.................... #endif 
....................      
.................... 	DS_String_To_Massiv_Clock_3by(u8SnoozeDelay,cMsgClockP); 
0535:  MOVLW  20
0536:  MOVLB  01
0537:  MOVWF  34
0538:  MOVLW  25
0539:  MOVWF  33
053A:  MOVF   2C,W
053B:  MOVWF  36
053C:  MOVF   2B,W
053D:  MOVWF  35
053E:  MOVLB  00
053F:  CALL   4A8
....................      
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('N');putc('e');putc('w'); 
0540:  MOVLW  0D
0541:  CALL   02D
0542:  MOVLW  4E
0543:  CALL   02D
0544:  MOVLW  65
0545:  CALL   02D
0546:  MOVLW  77
0547:  CALL   02D
....................     DS_Print_Clock_3by(u8SnoozeDelay,1); 
0548:  MOVLW  20
0549:  MOVLB  01
054A:  MOVWF  3C
054B:  MOVLW  25
054C:  MOVWF  3B
054D:  MOVLW  01
054E:  MOVWF  3D
054F:  MOVLB  00
0550:  CALL   401
.................... #endif 
0551:  MOVLP  08
0552:  GOTO   2BB (RETURN)
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void SetInitialDelay_3by(char * cMsgClockP) 
.................... { 
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('O');putc('l');putc('d'); 
0553:  MOVLW  0D
0554:  CALL   02D
0555:  MOVLW  4F
0556:  CALL   02D
0557:  MOVLW  6C
0558:  CALL   02D
0559:  MOVLW  64
055A:  CALL   02D
....................     DS_Print_Clock_3by(u8InitialDelay,1); 
055B:  MOVLW  20
055C:  MOVLB  01
055D:  MOVWF  3C
055E:  MOVLW  1F
055F:  MOVWF  3B
0560:  MOVLW  01
0561:  MOVWF  3D
0562:  MOVLB  00
0563:  CALL   401
.................... #endif 
....................      
.................... 	DS_String_To_Massiv_Clock_3by(u8InitialDelay,cMsgClockP); 
0564:  MOVLW  20
0565:  MOVLB  01
0566:  MOVWF  34
0567:  MOVLW  1F
0568:  MOVWF  33
0569:  MOVF   2C,W
056A:  MOVWF  36
056B:  MOVF   2B,W
056C:  MOVWF  35
056D:  MOVLB  00
056E:  CALL   4A8
....................      
.................... #ifdef DebugPrintClock 
....................     putc(13);putc('N');putc('e');putc('w'); 
056F:  MOVLW  0D
0570:  CALL   02D
0571:  MOVLW  4E
0572:  CALL   02D
0573:  MOVLW  65
0574:  CALL   02D
0575:  MOVLW  77
0576:  CALL   02D
....................     DS_Print_Clock_3by(u8InitialDelay,1); 
0577:  MOVLW  20
0578:  MOVLB  01
0579:  MOVWF  3C
057A:  MOVLW  1F
057B:  MOVWF  3B
057C:  MOVLW  01
057D:  MOVWF  3D
057E:  MOVLB  00
057F:  CALL   401
.................... #endif 
0580:  MOVLP  08
0581:  GOTO   2D1 (RETURN)
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void AddTimeToAlarm_3by(void) 
.................... { 
....................     uint8 u8AlarmTempL[7]; 
....................     uint8 u8SnoozeDelayTempL[7]; 
....................      
....................     putc(13); 
*
0663:  MOVLW  0D
0664:  CALL   02D
....................     putc('O');putc('l');putc('d');putc('A');putc('l');putc('a'); 
0665:  MOVLW  4F
0666:  CALL   02D
0667:  MOVLW  6C
0668:  CALL   02D
0669:  MOVLW  64
066A:  CALL   02D
066B:  MOVLW  41
066C:  CALL   02D
066D:  MOVLW  6C
066E:  CALL   02D
066F:  MOVLW  61
0670:  CALL   02D
....................     putc('r');putc('m'); 
0671:  MOVLW  72
0672:  CALL   02D
0673:  MOVLW  6D
0674:  CALL   02D
....................     putc(' ');putc(' '); 
0675:  MOVLW  20
0676:  CALL   02D
0677:  MOVLW  20
0678:  CALL   02D
....................     putc('S');putc('n');putc('o');putc('o');putc('z');putc('e'); 
0679:  MOVLW  53
067A:  CALL   02D
067B:  MOVLW  6E
067C:  CALL   02D
067D:  MOVLW  6F
067E:  CALL   02D
067F:  MOVLW  6F
0680:  CALL   02D
0681:  MOVLW  7A
0682:  CALL   02D
0683:  MOVLW  65
0684:  CALL   02D
....................  
....................     DS_Print_Clock_3by(u8Alarm, 1); 
0685:  MOVLW  20
0686:  MOVLB  01
0687:  MOVWF  3C
0688:  MOVLW  19
0689:  MOVWF  3B
068A:  MOVLW  01
068B:  MOVWF  3D
068C:  MOVLB  00
068D:  CALL   401
....................     putc(' ');putc(' '); 
068E:  MOVLW  20
068F:  CALL   02D
0690:  MOVLW  20
0691:  CALL   02D
....................     DS_Print_Clock_3by(u8SnoozeDelay, 0); 
0692:  MOVLW  20
0693:  MOVLB  01
0694:  MOVWF  3C
0695:  MOVLW  25
0696:  MOVWF  3B
0697:  CLRF   3D
0698:  MOVLB  00
0699:  CALL   401
....................     putc(10);putc(13); 
069A:  MOVLW  0A
069B:  CALL   02D
069C:  MOVLW  0D
069D:  CALL   02D
....................              
.................... //    DigitsToInt ( u8Alarm, u8AlarmTempL ); 
.................... //    DigitsToInt ( u8SnoozeDelay, u8SnoozeDelayTempL ); 
....................  
....................     AddTimeToClock( u8Alarm, u8SnoozeDelay ); 
069E:  MOVLW  20
069F:  MOVLB  01
06A0:  MOVWF  3C
06A1:  MOVLW  19
06A2:  MOVWF  3B
06A3:  MOVLW  20
06A4:  MOVWF  3E
06A5:  MOVLW  25
06A6:  MOVWF  3D
.................... //    IntToDigits ( u8AlarmTempL, u8Alarm); 
....................  
....................     putc('N');putc('e');putc('w'); 
*
0744:  MOVLW  4E
0745:  MOVLB  00
0746:  CALL   02D
0747:  MOVLW  65
0748:  CALL   02D
0749:  MOVLW  77
074A:  CALL   02D
....................     putc('A');putc('l');putc('a');putc('r');putc('m'); 
074B:  MOVLW  41
074C:  CALL   02D
074D:  MOVLW  6C
074E:  CALL   02D
074F:  MOVLW  61
0750:  CALL   02D
0751:  MOVLW  72
0752:  CALL   02D
0753:  MOVLW  6D
0754:  CALL   02D
....................     DS_Print_Clock_3by(u8Alarm, 1); 
0755:  MOVLW  20
0756:  MOVLB  01
0757:  MOVWF  3C
0758:  MOVLW  19
0759:  MOVWF  3B
075A:  MOVLW  01
075B:  MOVWF  3D
075C:  MOVLB  00
075D:  CALL   401
075E:  MOVLP  08
075F:  GOTO   2F1 (RETURN)
.................... } 
....................  
.................... #include "PWMandTime.c" 
.................... #include <PWMandTime.h> 
.................... //#ifndef #define PORTA0  
.................... //    #Bit    PORTA0      =   PORTA.0 
.................... //    #Bit    PORTA1      =   PORTA.1 
.................... //    #Bit    PORTA2      =   PORTA.2 
.................... //    #Bit    PORTA3      =   PORTA.3 
.................... //    #Bit    PORTA4      =   PORTA.4 
.................... //    #Bit    PORTA5      =   PORTA.5 
.................... //    #Bit    PORTA6      =   PORTA.6 
.................... //    #Bit    PORTA7      =   PORTA.7 
.................... //#endif 
.................... // 
.................... //#ifndef PORTC0 
.................... //    #Bit    PORTC0      =   PORTC.0 
.................... //    #Bit    PORTC1      =   PORTC.1 
.................... //    #Bit    PORTC2      =   PORTC.2 
.................... //    #Bit    PORTC3      =   PORTC.3 
.................... //    #Bit    PORTC4      =   PORTC.4 
.................... //    #Bit    PORTC5      =   PORTC.5 
.................... //    #Bit    PORTC6      =   PORTC.6 
.................... //    #Bit    PORTC7      =   PORTC.7 
.................... //#endif 
....................  
.................... #ifndef PWMandTimeFile 
.................... #define PWMandTimeFile 
....................  
.................... #define RTCInterruptPIN		0x01 
.................... #define UARTInterruptPIN	0x02 
....................  
.................... #define Right (0)   //pin_B 
.................... #define Left  (1)   //pin_B 
....................  
.................... #define PWM1    (0) 
.................... #define PWM2    (1) 
.................... #define PWM3    (2) 
....................  
.................... #define R_PWM1    PORTA3 
.................... #define R_PWM2    PORTA1 
.................... #define R_PWM3    PORTA2 
....................  
.................... #define L_PWM1    PORTA7 
.................... #define L_PWM2    PORTA6 
.................... #define L_PWM3    PORTA5 
....................  
.................... #define R_PWM1TRIS    TRISA1//ok 
.................... #define R_PWM2TRIS    TRISA2 
.................... #define R_PWM3TRIS    TRISA3 
....................  
.................... #define L_PWM1TRIS    TRISA5 
.................... #define L_PWM2TRIS    TRISA7 
.................... #define L_PWM3TRIS    TRISA6 
....................  
.................... void SetAllPWM( unsigned int16 u16PWM1P, 
....................                 unsigned int16 u16PWM2P, 
....................                 unsigned int16 u16PWM3P); 
....................  
.................... void Timer0_Init(void); 
.................... void Timer2_Init(void); 
....................  
.................... void PWM_Init(void); 
....................  
.................... void StartWakeUpFromUART(void); 
.................... void StopWakeUpFromUART(void); 
....................  
.................... unsigned int8 PWMDC[2][3] = {{ 0, 0, 0 },{ 0, 0, 0 }}; 
.................... unsigned int8 u8PWMCounter = 0; 
....................  
.................... #endif //#define PWMandTimeFile 
....................  
....................  
.................... #INT_TIMER0 
.................... void Timer0_Interrupt(void) 
.................... { 
.................... //    unsigned int8 u8LeftLEDL=0; 
.................... //after tests TMR is set to this number 
.................... //and it is equal to 400 Hz 
....................     TMR0=116; 
*
01A0:  MOVLW  74
01A1:  MOVWF  15
....................     //255-116=139 
....................      
....................     u16ByteFlags |= EffectIncrementFlagMask; 
01A2:  BSF    4B.2
....................  
....................     if(u8PWMCounter <= PWMDC[Right][PWM1]) 
01A3:  MOVF   56,W
01A4:  SUBWF  50,W
01A5:  BTFSS  03.0
01A6:  GOTO   1A9
....................     { 
....................         R_PWM1 = 1; 
01A7:  BSF    0C.3
....................     } 
01A8:  GOTO   1AA
....................     else 
....................     { 
....................         R_PWM1 = 0; 
01A9:  BCF    0C.3
....................     } 
....................     if(u8PWMCounter <= PWMDC[Right][PWM2]) 
01AA:  MOVF   56,W
01AB:  SUBWF  51,W
01AC:  BTFSS  03.0
01AD:  GOTO   1B0
....................     { 
....................         R_PWM2 = 1; 
01AE:  BSF    0C.1
....................     } 
01AF:  GOTO   1B1
....................     else 
....................     { 
....................         R_PWM2 = 0; 
01B0:  BCF    0C.1
....................     } 
....................  
....................     if(u8PWMCounter <= PWMDC[Right][PWM3]) 
01B1:  MOVF   56,W
01B2:  SUBWF  52,W
01B3:  BTFSS  03.0
01B4:  GOTO   1B7
....................     { 
....................         R_PWM3 = 1; 
01B5:  BSF    0C.2
....................     } 
01B6:  GOTO   1B8
....................     else 
....................     { 
....................         R_PWM3 = 0; 
01B7:  BCF    0C.2
....................     } 
.................... /////////////////// 
....................     if(u8PWMCounter <= PWMDC[Left][PWM1]) 
01B8:  MOVF   56,W
01B9:  SUBWF  53,W
01BA:  BTFSS  03.0
01BB:  GOTO   1BE
....................     { 
....................         L_PWM1 = 1; 
01BC:  BSF    0C.7
....................     } 
01BD:  GOTO   1BF
....................     else 
....................     { 
....................         L_PWM1 = 0; 
01BE:  BCF    0C.7
....................     } 
....................  
....................     if(u8PWMCounter <= PWMDC[Left][PWM2]) 
01BF:  MOVF   56,W
01C0:  SUBWF  54,W
01C1:  BTFSS  03.0
01C2:  GOTO   1C5
....................     { 
....................         L_PWM2 = 1; 
01C3:  BSF    0C.6
....................     } 
01C4:  GOTO   1C6
....................     else 
....................     { 
....................         L_PWM2 = 0; 
01C5:  BCF    0C.6
....................     } 
....................     if(u8PWMCounter <= PWMDC[Left][PWM3]) 
01C6:  MOVF   56,W
01C7:  SUBWF  55,W
01C8:  BTFSS  03.0
01C9:  GOTO   1CC
....................     { 
....................         L_PWM3 = 1; 
01CA:  BSF    0C.5
....................     } 
01CB:  GOTO   1CD
....................     else 
....................     { 
....................         L_PWM3 = 0; 
01CC:  BCF    0C.5
....................     } 
.................... /////////////////// 
....................  
....................     if(u8PWMCounter >= 32) 
01CD:  MOVF   56,W
01CE:  SUBLW  1F
01CF:  BTFSS  03.0
....................     { 
....................         u8PWMCounter = 0; 
01D0:  CLRF   56
....................     } 
....................     u8PWMCounter++; 
01D1:  INCF   56,F
01D2:  BCF    0B.2
01D3:  MOVLP  00
01D4:  GOTO   01E
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Timer0_Init(void) 
.................... { 
.................... //tick is 500 ns 
.................... //TIMER0 = 156 
.................... //(500*10^-9 * 139) = 69.5 * 10^-6 
.................... //1 / (69.5 * 10-6 * 32) = 449.64 Hz 
....................      
....................     //TIMER0 
....................     //Prescaler is 1 : 2, 
....................     //((16MHz/4)/2) 
....................     OPTION_REG &= ~(0b10111111); 
*
02D6:  MOVLW  40
02D7:  MOVLB  01
02D8:  ANDWF  15,F
.................... //    OPTION_REG |=   0b01000000; 
....................     TMR0IE = 1;     //enable_interrupts(INT_TIMER0); 
02D9:  BSF    0B.5
.................... //    GIE = 1;        //enable_interrupts(GLOBAL); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void I2C_Reade_Triger_Init(void) 
.................... { 
.................... //  PORTB0 
.................... //  Interupt happens in every 1s 
....................     IOCBP |= RTCInterruptPIN; //IOCBP: INTERRUPT-ON-CHANGE POSITIVE EDGE REGISTER 
*
02CA:  MOVLB  07
02CB:  BSF    14.0
.................... //    IOCBN |= RTCInterruptPIN; //IOCBN: INTERRUPT-ON-CHANGE NEGATIVE EDGE REGISTER 
....................      
.................... //WakeUp on RS232 
.................... //    IOCBN |= UARTInterruptPIN; //IOCBN: INTERRUPT-ON-CHANGE NEGATIVE EDGE REGISTER 
....................     StartWakeUpFromUART(); 
02CC:  MOVLB  00
02CD:  CALL   20C
....................      
....................     TRISB |= (UARTInterruptPIN || RTCInterruptPIN); //PORTB0 PORTB3 is input 
02CE:  MOVLB  01
02CF:  BSF    0D.1
....................      
....................     OPTION_REG &= ~(0x80); //Weak pull-ups are enabled  
02D0:  BCF    15.7
....................                            //by individual WPUx latch values 
....................      
....................     WPUB  |= RTCInterruptPIN; //PORTB0 enable PULL-UP resistor for RTCInterruptPIN 
02D1:  MOVLB  04
02D2:  BSF    0D.0
....................      
....................     IOCBF = 0; // INTERRUPT-ON-CHANGE FLAG REGISTER 
02D3:  MOVLB  07
02D4:  CLRF   16
....................     IOCIE = 1; // Interrupt-on-Change Enable bit 
02D5:  BSF    0B.3
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #INT_RB 
.................... void Interrupt_on_Change_ISR(void) 
*
01D5:  MOVLB  01
01D6:  CLRF   52
.................... { 
....................     uint8 B = 0; 
....................      
....................     B = PORTB; 
01D7:  MOVLB  00
01D8:  MOVF   0D,W
01D9:  MOVLB  01
01DA:  MOVWF  52
....................      
....................     if(RTCInterruptPIN == (IOCBF & RTCInterruptPIN))//1s interupt reade clock 
01DB:  MOVLB  07
01DC:  MOVF   16,W
01DD:  ANDLW  01
01DE:  SUBLW  01
01DF:  BTFSS  03.2
01E0:  GOTO   1E5
....................     { 
....................         u16ByteFlags |= OneSecondTaskFlagMask; 
01E1:  MOVLB  00
01E2:  BSF    4B.6
....................         IOCBF &= ~RTCInterruptPIN; // INTERRUPT-ON-CHANGE FLAG REGISTER 
01E3:  MOVLB  07
01E4:  BCF    16.0
....................     } 
....................     if(UARTInterruptPIN == (IOCBF & UARTInterruptPIN))//UART 
01E5:  MOVF   16,W
01E6:  ANDLW  02
01E7:  SUBLW  02
01E8:  BTFSS  03.2
01E9:  GOTO   1EF
....................     { 
....................  
.................... //CMNT:0 
.................... //???? ???????? ?? ????? ? ??????? ????????? ??? ??????? ?? PORTB 
.................... //??? ?? ????????? ?? ????????? ?? ???????, 
.................... //?? ?? ???? ?? ????? ?????? ????????? ?? UART 
.................... //???? ?????????? ?? ???? ????????? ??? ?????? ??????  
.................... //?? ????????? ?? ????????? ?? ??????? 
....................  
....................         IOCBF &= ~UARTInterruptPIN; // INTERRUPT-ON-CHANGE FLAG REGISTER 
01EA:  BCF    16.1
.................... 		StopWakeUpFromUART(); 
....................         u16ByteFlags2 |= SleepDelayFlagMask; 
*
01EC:  MOVLB  00
01ED:  BSF    4D.0
01EE:  MOVLB  07
....................          
.................... //        putc('A'); 
....................     } 
....................  
01EF:  MOVLW  FF
01F0:  XORWF  16,W
01F1:  ANDWF  16,F
01F2:  BCF    0B.0
01F3:  MOVLP  00
01F4:  MOVLB  00
01F5:  GOTO   01E
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void StartWakeUpFromUART(void) 
.................... { 
....................     IOCBN |= UARTInterruptPIN; 
*
020C:  MOVLB  07
020D:  BSF    15.1
020E:  MOVLB  00
020F:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void StopWakeUpFromUART(void) 
.................... { 
....................     IOCBN &= ~UARTInterruptPIN; 
*
01EB:  BCF    15.1
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void LEDInit(void) 
.................... { 
....................     R_PWM1TRIS = 0; 
*
02DA:  BCF    0C.1
....................     R_PWM2TRIS = 0; 
02DB:  BCF    0C.2
....................     R_PWM3TRIS = 0; 
02DC:  BCF    0C.3
....................  
....................     L_PWM1TRIS = 0; 
02DD:  BCF    0C.5
....................     L_PWM2TRIS = 0; 
02DE:  BCF    0C.7
....................     L_PWM3TRIS = 0; 
02DF:  BCF    0C.6
....................  
....................     R_PWM1 = 1; 
02E0:  MOVLB  00
02E1:  BSF    0C.3
....................     R_PWM2 = 1; 
02E2:  BSF    0C.1
....................     R_PWM3 = 1; 
02E3:  BSF    0C.2
....................  
....................     L_PWM1 = 1; 
02E4:  BSF    0C.7
....................     L_PWM2 = 1; 
02E5:  BSF    0C.6
....................     L_PWM3 = 1; 
02E6:  BSF    0C.5
....................      
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "Effects.c" 
....................  
.................... #include <Effects.h> 
....................  
.................... #ifndef EFFECT 
.................... #define	EFFECT 
....................  
.................... #define	MaxLED 5 
.................... int8 u8IncMaskFlag = 0; 
....................  
.................... int8 u8IncPWMFlag = 0b00111111; 
....................  
.................... int8 u8IncLEDFlag = 1; 
....................  
.................... //int1 u1Increment1L = 1; 
.................... //int1 u1Increment2L = 1; 
.................... //int1 u1Increment3L = 1; 
.................... //int1 u1Increment4L = 1; 
.................... //int1 u1Increment5L = 1; 
.................... //int1 u1Increment6L = 1; 
....................  
.................... uint8 u8Moove[6] = { 0, 0, 0, 0, 0, 0 }; 
.................... //uint8 u8Moove[6] = { 0, 0, 0, 0, 0, 0 }; 
....................  
.................... uint8 u8Duty[6] = { 0, 0, 0, 0, 0, 0 }; 
....................  
.................... //int1 u1StartFlag1L = 0; 
.................... int1 u1StartFlagGlowAltL = 0; 
.................... //     int1 u1StartFlag2L = 1; 
.................... //     int1 u1StartFlag3L = 1; 
....................  
....................  
.................... unsigned int16 u16EffectCounterL = 0; 
....................  
.................... void Sweep_Left(void); 
.................... void Glow_Alt(void); 
.................... void Effects_Task(void); 
.................... void Rotate_Left_Incrementation_Mask(void); 
.................... void Set_Xth_Bit(uint8 *u8ByteP, uint8 u8XthBitP); 
.................... void Disable_Port(void); 
.................... void NextLed(uint8 u8CurLEDP); 
.................... #endif	/* EFFECT*/ 
....................  
....................  
....................  
.................... #define MaxPWM 32 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Effects_Task(void) 
.................... { 
....................     u16EffectCounterL++; 
*
059F:  INCF   35,F
05A0:  BTFSC  03.2
05A1:  INCF   36,F
....................     if(250 == u16EffectCounterL) 
05A2:  MOVF   35,W
05A3:  SUBLW  FA
05A4:  BTFSS  03.2
05A5:  GOTO   661
05A6:  MOVF   36,F
05A7:  BTFSS  03.2
05A8:  GOTO   661
....................     { 
....................         u16EffectCounterL=0; 
05A9:  CLRF   36
05AA:  CLRF   35
....................         if(1 == u1StartFlagGlowAltL) 
05AB:  BTFSS  34.0
05AC:  GOTO   661
....................         { 
....................             Glow_Alt();//Sweep_Left();// 
....................         } 
....................     } 
*
0661:  MOVLP  08
0662:  GOTO   2E1 (RETURN)
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Rotate_Left_Incrementation_Mask(void) 
.................... { 
....................     if(0 == (u8IncMaskFlag & 0b11100000)) 
....................     { 
....................         u8IncMaskFlag <<= 1; 
....................     } 
....................     else 
....................     { 
....................         u8IncMaskFlag = 0b00000001; 
....................     } 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Set_Xth_Bit(uint8 *u8ByteP, uint8 u8XthBitP) 
.................... { 
....................     *u8ByteP = 0b00000001; 
*
0582:  MOVLB  01
0583:  MOVF   32,W
0584:  MOVWF  04
0585:  MOVF   33,W
0586:  MOVWF  05
0587:  MOVLW  01
0588:  MOVWF  00
....................     if(0 != u8XthBitP) 
0589:  MOVF   34,F
058A:  BTFSC  03.2
058B:  GOTO   59D
....................     { 
....................         *u8ByteP <<= u8XthBitP; 
058C:  MOVF   33,W
058D:  MOVWF  7A
058E:  MOVF   32,W
058F:  MOVWF  04
0590:  MOVF   33,W
0591:  MOVWF  05
0592:  MOVF   00,W
0593:  MOVWF  77
0594:  MOVF   34,W
0595:  MOVWF  78
0596:  BTFSC  03.2
0597:  GOTO   59B
0598:  LSLF   77,F
0599:  DECFSZ 78,F
059A:  GOTO   598
059B:  MOVF   77,W
059C:  MOVWF  00
....................     } 
059D:  MOVLB  00
059E:  RETURN
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Glow_Alt(void) 
*
05AD:  MOVLB  01
05AE:  CLRF   2B
.................... { 
....................     uint8 u8CurLEDL=0; 
....................      
....................     for(u8CurLEDL=0;u8CurLEDL<6;u8CurLEDL++) 
05AF:  CLRF   2B
05B0:  MOVF   2B,W
05B1:  SUBLW  05
05B2:  BTFSS  03.0
05B3:  GOTO   654
....................     {         
....................         if(0 != u8Moove[u8CurLEDL]) 
05B4:  MOVLW  08
05B5:  ADDWF  2B,W
05B6:  MOVWF  04
05B7:  MOVLW  20
05B8:  MOVWF  05
05B9:  BTFSC  03.0
05BA:  INCF   05,F
05BB:  MOVF   00,W
05BC:  BTFSC  03.2
05BD:  GOTO   650
....................         { 
....................             Set_Xth_Bit(&u8IncMaskFlag, u8CurLEDL); 
05BE:  MOVLW  20
05BF:  MOVWF  33
05C0:  MOVLW  05
05C1:  MOVWF  32
05C2:  MOVF   2B,W
05C3:  MOVWF  34
05C4:  MOVLB  00
05C5:  CALL   582
....................             if(u8IncMaskFlag == (u8IncPWMFlag & u8IncMaskFlag))//proveriava se koeficienta na 
05C6:  MOVF   26,W
05C7:  ANDWF  25,W
05C8:  SUBWF  25,W
05C9:  BTFSS  03.2
05CA:  GOTO   62C
....................             {                                                  //zapylvane uvelichaca li se ili namaliava 
....................                 if(MaxPWM <= u8Duty[u8CurLEDL]) 
05CB:  MOVLW  0E
05CC:  MOVLB  01
05CD:  ADDWF  2B,W
05CE:  MOVWF  04
05CF:  MOVLW  20
05D0:  MOVWF  05
05D1:  BTFSC  03.0
05D2:  INCF   05,F
05D3:  MOVF   00,W
05D4:  SUBLW  1F
05D5:  BTFSC  03.0
05D6:  GOTO   620
....................                 { 
....................                     u8IncPWMFlag &= (~u8IncMaskFlag); 
05D7:  MOVLB  00
05D8:  MOVF   25,W
05D9:  XORLW  FF
05DA:  ANDWF  26,F
....................                     NextLed(u8CurLEDL); 
05DB:  MOVLB  01
05DC:  MOVF   2B,W
05DD:  MOVWF  2E
....................                 } 
*
061E:  GOTO   62B
061F:  MOVLB  01
....................                 else 
....................                 { 
....................                     u8Duty[u8CurLEDL] += 1; 
0620:  MOVLW  0E
0621:  ADDWF  2B,W
0622:  MOVWF  04
0623:  MOVLW  20
0624:  MOVWF  05
0625:  BTFSC  03.0
0626:  INCF   05,F
0627:  MOVLW  01
0628:  ADDWF  00,W
0629:  MOVWF  00
062A:  MOVLB  00
....................                 } 
....................             } 
062B:  GOTO   651
....................             else 
....................             { 
....................                 if(0 == u8Duty[u8CurLEDL]) 
062C:  MOVLW  0E
062D:  MOVLB  01
062E:  ADDWF  2B,W
062F:  MOVWF  04
0630:  MOVLW  20
0631:  MOVWF  05
0632:  BTFSC  03.0
0633:  INCF   05,F
0634:  MOVF   00,W
0635:  BTFSS  03.2
0636:  GOTO   646
....................                 { 
....................                     u8Moove[u8CurLEDL] -= 1; 
0637:  MOVLW  08
0638:  ADDWF  2B,W
0639:  MOVWF  04
063A:  MOVLW  20
063B:  MOVWF  05
063C:  BTFSC  03.0
063D:  INCF   05,F
063E:  MOVLW  01
063F:  SUBWF  00,W
0640:  MOVWF  00
....................                     u8IncPWMFlag |= u8IncMaskFlag; 
0641:  MOVLB  00
0642:  MOVF   25,W
0643:  IORWF  26,F
....................                 } 
0644:  GOTO   651
0645:  MOVLB  01
....................                 else 
....................                 { 
....................                     u8Duty[u8CurLEDL] -= 1; 
0646:  MOVLW  0E
0647:  ADDWF  2B,W
0648:  MOVWF  04
0649:  MOVLW  20
064A:  MOVWF  05
064B:  BTFSC  03.0
064C:  INCF   05,F
064D:  MOVLW  01
064E:  SUBWF  00,W
064F:  MOVWF  00
0650:  MOVLB  00
....................                 } 
....................             } 
....................         } 
0651:  MOVLB  01
0652:  INCF   2B,F
0653:  GOTO   5B0
....................     } 
....................  
....................     PWMDC[Right][PWM1] = u8Duty[0]; 
0654:  MOVLB  00
0655:  MOVF   2E,W
0656:  MOVWF  50
....................     PWMDC[Right][PWM2] = u8Duty[1]; 
0657:  MOVF   2F,W
0658:  MOVWF  51
....................     PWMDC[Right][PWM3] = u8Duty[2]; 
0659:  MOVF   30,W
065A:  MOVWF  52
....................     PWMDC[Left][PWM1] = u8Duty[3]; 
065B:  MOVF   31,W
065C:  MOVWF  53
....................     PWMDC[Left][PWM2] = u8Duty[4]; 
065D:  MOVF   32,W
065E:  MOVWF  54
....................     PWMDC[Left][PWM3] = u8Duty[5]; 
065F:  MOVF   33,W
0660:  MOVWF  55
....................  
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void NextLed(uint8 u8CurLEDP) 
*
05DE:  CLRF   2F
05DF:  CLRF   30
.................... { 
....................     uint8 u8NextLEDL = 0; 
....................     uint8 u8TempXthBit = 0; 
....................      
....................     if(0 != u8IncLEDFlag) 
05E0:  MOVLB  00
05E1:  MOVF   27,F
05E2:  BTFSC  03.2
05E3:  GOTO   5F4
....................     { 
....................         if( 5 == u8CurLEDP ) 
05E4:  MOVLB  01
05E5:  MOVF   2E,W
05E6:  SUBLW  05
05E7:  BTFSS  03.2
05E8:  GOTO   5EF
....................         { 
....................             u8IncLEDFlag = 0; 
05E9:  MOVLB  00
05EA:  CLRF   27
....................             u8NextLEDL = MaxLED - 1; 
05EB:  MOVLW  04
05EC:  MOVLB  01
05ED:  MOVWF  2F
....................         } 
05EE:  GOTO   5F2
....................         else 
....................         { 
....................             u8NextLEDL = u8CurLEDP + 1; 
05EF:  MOVLW  01
05F0:  ADDWF  2E,W
05F1:  MOVWF  2F
....................         } 
....................     } 
05F2:  GOTO   601
05F3:  MOVLB  00
....................     else 
....................     { 
....................         if( 0 == u8CurLEDP ) 
05F4:  MOVLB  01
05F5:  MOVF   2E,F
05F6:  BTFSS  03.2
05F7:  GOTO   5FE
....................         { 
....................             u8IncLEDFlag = 1; 
05F8:  MOVLW  01
05F9:  MOVLB  00
05FA:  MOVWF  27
....................             u8NextLEDL = 1; 
05FB:  MOVLB  01
05FC:  MOVWF  2F
....................         } 
05FD:  GOTO   601
....................         else 
....................         { 
....................             u8NextLEDL = u8CurLEDP - 1; 
05FE:  MOVLW  01
05FF:  SUBWF  2E,W
0600:  MOVWF  2F
....................         } 
....................     } 
....................     u8Moove[u8NextLEDL] = 1; 
0601:  MOVLW  08
0602:  ADDWF  2F,W
0603:  MOVWF  04
0604:  MOVLW  20
0605:  MOVWF  05
0606:  BTFSC  03.0
0607:  INCF   05,F
0608:  MOVLW  01
0609:  MOVWF  00
....................     u8Duty[u8NextLEDL] = 0; 
060A:  MOVLW  0E
060B:  ADDWF  2F,W
060C:  MOVWF  04
060D:  MOVLW  20
060E:  MOVWF  05
060F:  BTFSC  03.0
0610:  INCF   05,F
0611:  CLRF   00
....................     Set_Xth_Bit(&u8TempXthBit, u8NextLEDL); 
0612:  MOVLW  20
0613:  MOVWF  33
0614:  MOVLW  60
0615:  MOVWF  32
0616:  MOVF   2F,W
0617:  MOVWF  34
0618:  MOVLB  00
0619:  CALL   582
....................     u8IncPWMFlag |= u8TempXthBit; 
061A:  MOVLB  01
061B:  MOVF   30,W
061C:  MOVLB  00
061D:  IORWF  26,F
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //void Sweep_Left(void) 
.................... //{ 
.................... //    if(1 == u1StartFlag1L) 
.................... //    { 
.................... //        u1StartFlag1L = 0; 
.................... //        u8Moove[0] = 1; 
.................... //        u8Duty[0] = 0; 
.................... //        u1Increment1L = 1; 
.................... //    } 
.................... // 
.................... //    //////////////////////////////////////////// 
.................... //    if((1 == u1Increment1L) && (MaxPWM < u8Duty[0])) 
.................... //    { 
.................... //        u1Increment1L = 0; 
.................... //        u8Moove[1] = 1; 
.................... //        u8Duty[1] = 0; 
.................... //    } 
.................... //    if((0 == u1Increment1L) && (0 == u8Duty[0])) 
.................... //    { 
.................... //        u8Moove[0]--; 
.................... //        u1Increment1L = 1; 
.................... //    } 
.................... // 
.................... //    if(0 != u8Moove[0]) 
.................... //    { 
.................... //        if( 1 == u1Increment1L) 
.................... //        { 
.................... //            u8Duty[0] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[0] -= 1; 
.................... //        } 
.................... //    } 
.................... //        //////////////////////////////////////////// 
.................... //    if((1 == u1Increment2L) && (MaxPWM < u8Duty[1])) 
.................... //    { 
.................... //        u1Increment2L = 0; 
.................... //        u8Moove[2] = 1; 
.................... //        u8Duty[2] = 0; 
.................... //    } 
.................... //    if((0 == u1Increment2L) && (0 == u8Duty[1])) 
.................... //    { 
.................... //        u8Moove[1]--; 
.................... //        u1Increment2L = 1; 
.................... //    } 
.................... //    if(0 != u8Moove[1]) 
.................... //    { 
.................... //        if( 1 == u1Increment2L) 
.................... //        { 
.................... //            u8Duty[1] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[1] -= 1; 
.................... //        } 
.................... //    } 
.................... //        //////////////////////////////////////////// 
.................... //    if((1 == u1Increment3L) && (MaxPWM < u8Duty[2])) 
.................... //    { 
.................... //        u1Increment3L = 0; 
.................... //        u8Moove[3] = 1; 
.................... //        u8Duty[3] = 0; 
.................... //    } 
.................... //    if((0 == u1Increment3L) && (0 == u8Duty[2])) 
.................... //    { 
.................... //        u8Moove[2]--; 
.................... //        u1Increment3L = 1; 
.................... //    } 
.................... //    if(0 != u8Moove[2]) 
.................... //    { 
.................... //        if( 1 == u1Increment3L) 
.................... //        { 
.................... //            u8Duty[2] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[2] -= 1; 
.................... //        } 
.................... //    } 
.................... //        //////////////////////////////////////////// 
.................... //    if((1 == u1Increment4L) && (MaxPWM < u8Duty[3])) 
.................... //    { 
.................... //        u1Increment4L = 0; 
.................... //        u8Moove[4] = 1; 
.................... //        u8Duty[4] = 0; 
.................... //    } 
.................... //    if((0 == u1Increment4L) && (0 == u8Duty[3])) 
.................... //    { 
.................... //        u8Moove[3]--; 
.................... //        u1Increment4L = 1; 
.................... //    } 
.................... //    if(0 != u8Moove[3]) 
.................... //    { 
.................... //        if( 1 == u1Increment4L) 
.................... //        { 
.................... //            u8Duty[3] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[3] -= 1; 
.................... //        } 
.................... //    } 
.................... //        //////////////////////////////////////////// 
.................... //    if((1 == u1Increment5L) && (MaxPWM < u8Duty[4])) 
.................... //    { 
.................... //        u1Increment5L = 0; 
.................... //        u8Duty[5] = 0; 
.................... //        u8Moove[5] = 1; 
.................... //    } 
.................... //    if((0 == u1Increment5L) && (0 == u8Duty[4])) 
.................... //    { 
.................... //        u8Moove[4]--; 
.................... //        u1Increment5L = 1; 
.................... //    } 
.................... //    if(0 != u8Moove[4]) 
.................... //    { 
.................... //        if( 1 == u1Increment5L) 
.................... //        { 
.................... //            u8Duty[4] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[4] -= 1; 
.................... //        } 
.................... //    } 
.................... //        //////////////////////////////////////////// 
.................... //    if((1 == u1Increment6L) && (MaxPWM < u8Duty[5])) 
.................... //    { 
.................... //        u1Increment6L = 0; 
.................... //        u8Duty[0] = 0; 
.................... //        u8Moove[0] = 0;//This whill Loop the effect 
.................... //          
.................... //    } 
.................... //    if((0 == u1Increment6L) && (0 == u8Duty[5])) 
.................... //    { 
.................... //        u8Moove[5]--; 
.................... //        u1Increment6L = 1; 
.................... //        //This is the end of effect 
.................... //        //Terminate the effect 
.................... //         
.................... //        TMR0IE = 0; 
.................... //        u8SleepFlag = 1; 
.................... //        ////////////////////////// 
.................... //    } 
.................... //    if(0 != u8Moove[5]) 
.................... //    { 
.................... //        if( 1 == u1Increment6L) 
.................... //        { 
.................... //            u8Duty[5] += 1; 
.................... //        } 
.................... //        else 
.................... //        { 
.................... //            u8Duty[5] -= 1; 
.................... //        } 
.................... //    } 
.................... // 
.................... //    PWMDC[Right][PWM1] = u8Duty[0]; 
.................... //    PWMDC[Right][PWM2] = u8Duty[1]; 
.................... //    PWMDC[Right][PWM3] = u8Duty[2]; 
.................... //    PWMDC[Left][PWM1] = u8Duty[3]; 
.................... //    PWMDC[Left][PWM2] = u8Duty[4]; 
.................... //    PWMDC[Left][PWM3] = u8Duty[5]; 
.................... //     
.................... //} 
.................... /////////////////////////////////////////////////////////// 
.................... //void Disable_Port(void) 
.................... //{ 
.................... //    if(0 == u8Moove[0]) 
.................... //    { 
.................... //        R_PWM1TRIS = 1; 
.................... //    } 
.................... //    if(0 == u8Moove[1]) 
.................... //    { 
.................... //        R_PWM2TRIS = 1; 
.................... //    } 
.................... //    if(0 == u8Moove[2]) 
.................... //    { 
.................... //        R_PWM3TRIS = 1; 
.................... //    } 
.................... //    if(0 == u8Moove[3]) 
.................... //    { 
.................... //        L_PWM1TRIS = 1; 
.................... //    } 
.................... //    if(0 == u8Moove[4]) 
.................... //    { 
.................... //        L_PWM2TRIS = 1; 
.................... //    } 
.................... //    if(0 == u8Moove[5]) 
.................... //    { 
.................... //        L_PWM3TRIS = 1; 
.................... //    } 
.................... //     
.................... //} 
....................  
....................  
.................... void Main_Init(void) 
.................... { 
....................     while(0 == HFIOFS); 
*
02B7:  MOVLB  01
02B8:  BTFSS  1A.0
02B9:  GOTO   2B8
....................     Delay_ms(200); 
02BA:  MOVLW  C8
02BB:  MOVWF  32
02BC:  MOVLB  00
02BD:  CALL   1F6
....................      
....................     putc(13);putc('S');putc('t');putc('a');putc('r');putc('t'); 
02BE:  MOVLW  0D
02BF:  CALL   02D
02C0:  MOVLW  53
02C1:  CALL   02D
02C2:  MOVLW  74
02C3:  CALL   02D
02C4:  MOVLW  61
02C5:  CALL   02D
02C6:  MOVLW  72
02C7:  CALL   02D
02C8:  MOVLW  74
02C9:  CALL   02D
....................      
....................     I2C_Reade_Triger_Init(); 
....................     Timer0_Init(); 
....................     LEDInit(); 
....................      
....................     RCIF = 0;       //Clear USART Receive Interrupt Flag bit 
*
02E7:  BCF    11.5
....................     RCIE = 1;       // Enables the USART receive interrupt  //enable_interrupts(INT_RDA);// 
02E8:  MOVLB  01
02E9:  BSF    11.5
....................      
....................     PEIE = 1;       //Peripheral Interrupt Enable bit 
02EA:  BSF    0B.6
....................     GIE = 1;        //enable_interrupts(GLOBAL); 
02EB:  BSF    0B.7
....................      
....................     DS_Init(); 
*
03E8:  MOVLP  08
03E9:  GOTO   29E (RETURN)
.................... } 
....................  
.................... void Main(void) 
*
0A23:  MOVLW  7A
0A24:  MOVLB  01
0A25:  MOVWF  19
0A26:  MOVLB  03
0A27:  BSF    1F.3
0A28:  MOVLW  22
0A29:  MOVWF  1B
0A2A:  MOVLW  00
0A2B:  MOVWF  1C
0A2C:  MOVLW  A6
0A2D:  MOVWF  1E
0A2E:  MOVLW  90
0A2F:  MOVWF  1D
0A30:  MOVLB  01
0A31:  BSF    0E.3
0A32:  BSF    0E.4
0A33:  MOVLB  04
0A34:  BCF    17.0
0A35:  BCF    17.1
0A36:  BCF    17.3
0A37:  MOVLW  09
0A38:  MOVWF  12
0A39:  MOVLW  28
0A3A:  MOVWF  15
0A3B:  BCF    14.7
0A3C:  BCF    14.6
0A3D:  MOVLB  00
0A3E:  CLRF   25
0A3F:  MOVLW  3F
0A40:  MOVWF  26
0A41:  MOVLW  01
0A42:  MOVWF  27
0A43:  BCF    34.0
0A44:  CLRF   36
0A45:  CLRF   35
0A46:  CLRF   38
0A47:  CLRF   37
0A48:  CLRF   4C
0A49:  CLRF   4B
0A4A:  CLRF   4E
0A4B:  CLRF   4D
0A4C:  MOVLW  02
0A4D:  MOVWF  4F
0A4E:  CLRF   56
0A4F:  CLRF   71
0A50:  CLRF   72
0A51:  MOVLB  0F
0A52:  CLRF   11
0A53:  CLRF   12
0A54:  CLRF   18
0A55:  CLRF   19
0A56:  CLRF   1A
0A57:  MOVLB  03
0A58:  CLRF   0C
0A59:  CLRF   0D
0A5A:  MOVLB  02
0A5B:  CLRF   12
0A5C:  CLRF   11
0A5D:  CLRF   14
0A5E:  CLRF   13
0A5F:  GOTO   27F
0A60:  DATA 0C,34
0A61:  DATA 40,34
0A62:  DATA 28,34
0A63:  DATA 00,34
0A64:  DATA 04,34
0A65:  DATA 00,34
0A66:  DATA 39,34
0A67:  DATA 05,34
0A68:  DATA 09,34
0A69:  DATA 05,34
0A6A:  DATA 09,34
0A6B:  DATA 04,34
0A6C:  DATA C0,34
0A6D:  DATA 00,34
0A6E:  DATA 0A,34
0A6F:  DATA 80,34
0A70:  DATA 03,34
0A71:  DATA 00,34
0A72:  DATA 00,34
0A73:  DATA 04,34
0A74:  DATA 05,34
0A75:  DATA 09,34
0A76:  DATA 05,34
0A77:  DATA 09,34
0A78:  DATA 02,34
0A79:  DATA 03,34
0A7A:  DATA 06,34
0A7B:  DATA 40,34
0A7C:  DATA 50,34
0A7D:  DATA 00,34
0A7E:  DATA 00,34
0A7F:  MOVLW  0A
0A80:  MOVWF  05
0A81:  MOVLW  60
0A82:  MOVWF  04
0A83:  BSF    05.7
0A84:  MOVIW  [FSR0++],W
0A85:  MOVWF  77
0A86:  XORLW  00
0A87:  BTFSC  03.2
0A88:  GOTO   299
0A89:  MOVIW  [FSR0++],W
0A8A:  MOVWF  78
0A8B:  BTFSC  78.7
0A8C:  GOTO   291
0A8D:  ANDLW  0F
0A8E:  MOVWF  07
0A8F:  MOVIW  [FSR0++],W
0A90:  MOVWF  06
0A91:  BTFSC  78.6
0A92:  MOVIW  [FSR0++],W
0A93:  BTFSS  78.6
0A94:  MOVIW  [FSR0++],W
0A95:  MOVWI  W,[FSR1++]
0A96:  DECFSZ 77,F
0A97:  GOTO   293
0A98:  GOTO   284
0A99:  MOVLB  01
0A9A:  CLRF   23
.................... { 
....................     uint8 u8SleepCountL = 0; 
....................     uint8 u8ClockL[7]; 
....................     Main_Init(); 
0A9B:  MOVLP  00
0A9C:  MOVLB  00
0A9D:  GOTO   2B7
0A9E:  MOVLP  08
....................  
....................     while(TRUE) 
....................     { 
....................         if( (0 != u16ByteFlags) || (0 != u8StaicByteFlags) ) 
0A9F:  MOVF   4B,F
0AA0:  BTFSS  03.2
0AA1:  GOTO   2A8
0AA2:  MOVF   4C,F
0AA3:  BTFSS  03.2
0AA4:  GOTO   2A8
0AA5:  MOVF   4F,F
0AA6:  BTFSC  03.2
0AA7:  GOTO   424
....................         { 
....................             if( SetSnoozeDelayFlagMask == ( u16ByteFlags & SetSnoozeDelayFlagMask ) ) 
0AA8:  MOVF   4B,W
0AA9:  ANDLW  01
0AAA:  MOVWF  77
0AAB:  CLRF   7A
0AAC:  MOVF   77,W
0AAD:  SUBLW  01
0AAE:  BTFSS  03.2
0AAF:  GOTO   2BE
0AB0:  MOVF   7A,F
0AB1:  BTFSS  03.2
0AB2:  GOTO   2BE
....................             { 
....................                 SetSnoozeDelay_3by(cMsgClock); 
0AB3:  MOVLW  20
0AB4:  MOVLB  01
0AB5:  MOVWF  2C
0AB6:  MOVLW  37
0AB7:  MOVWF  2B
0AB8:  MOVLP  00
0AB9:  MOVLB  00
0ABA:  GOTO   524
0ABB:  MOVLP  08
....................                 u16ByteFlags &= ~SetSnoozeDelayFlagMask; 
0ABC:  BCF    4B.0
0ABD:  CLRF   4C
....................             } 
....................  
....................             if( SetInitialDelayFlagMask == ( u16ByteFlags & SetInitialDelayFlagMask ) ) 
0ABE:  MOVF   4B,W
0ABF:  ANDLW  02
0AC0:  MOVWF  77
0AC1:  CLRF   7A
0AC2:  MOVF   77,W
0AC3:  SUBLW  02
0AC4:  BTFSS  03.2
0AC5:  GOTO   2D4
0AC6:  MOVF   7A,F
0AC7:  BTFSS  03.2
0AC8:  GOTO   2D4
....................             { 
....................                 SetInitialDelay_3by(cMsgClock); 
0AC9:  MOVLW  20
0ACA:  MOVLB  01
0ACB:  MOVWF  2C
0ACC:  MOVLW  37
0ACD:  MOVWF  2B
0ACE:  MOVLP  00
0ACF:  MOVLB  00
0AD0:  GOTO   553
0AD1:  MOVLP  08
....................                 u16ByteFlags &= ~SetInitialDelayFlagMask; 
0AD2:  BCF    4B.1
0AD3:  CLRF   4C
....................             } 
....................  
....................             if( EffectIncrementFlagMask == ( u16ByteFlags & EffectIncrementFlagMask ) ) 
0AD4:  MOVF   4B,W
0AD5:  ANDLW  04
0AD6:  MOVWF  77
0AD7:  CLRF   7A
0AD8:  MOVF   77,W
0AD9:  SUBLW  04
0ADA:  BTFSS  03.2
0ADB:  GOTO   2E4
0ADC:  MOVF   7A,F
0ADD:  BTFSS  03.2
0ADE:  GOTO   2E4
....................             { 
....................                 Effects_Task(); 
0ADF:  MOVLP  00
0AE0:  GOTO   59F
0AE1:  MOVLP  08
....................                 u16ByteFlags &= ~EffectIncrementFlagMask; 
0AE2:  BCF    4B.2
0AE3:  CLRF   4C
....................             }  
....................  
....................             if( AddSnoozeDelayFlagMask == ( u16ByteFlags & AddSnoozeDelayFlagMask ) ) 
0AE4:  MOVF   4B,W
0AE5:  ANDLW  08
0AE6:  MOVWF  77
0AE7:  CLRF   7A
0AE8:  MOVF   77,W
0AE9:  SUBLW  08
0AEA:  BTFSS  03.2
0AEB:  GOTO   2F4
0AEC:  MOVF   7A,F
0AED:  BTFSS  03.2
0AEE:  GOTO   2F4
....................             { 
....................                 AddTimeToAlarm_3by(); 
0AEF:  MOVLP  00
0AF0:  GOTO   663
0AF1:  MOVLP  08
....................                 u16ByteFlags &= ~AddSnoozeDelayFlagMask; 
0AF2:  BCF    4B.3
0AF3:  CLRF   4C
....................             } 
....................              
....................             if( SetAlarmFlagMask == ( u16ByteFlags & SetAlarmFlagMask ) ) 
0AF4:  MOVF   4B,W
0AF5:  ANDLW  10
0AF6:  MOVWF  77
0AF7:  CLRF   7A
0AF8:  MOVF   77,W
0AF9:  SUBLW  10
0AFA:  BTFSS  03.2
0AFB:  GOTO   319
0AFC:  MOVF   7A,F
0AFD:  BTFSS  03.2
0AFE:  GOTO   319
....................             { 
....................                 DS_String_To_Massiv_Clock_3by(u8Alarm,cMsgClock); 
0AFF:  MOVLW  20
0B00:  MOVLB  01
0B01:  MOVWF  34
0B02:  MOVLW  19
0B03:  MOVWF  33
0B04:  MOVLW  20
0B05:  MOVWF  36
0B06:  MOVLW  37
0B07:  MOVWF  35
0B08:  MOVLP  00
0B09:  MOVLB  00
0B0A:  CALL   4A8
0B0B:  MOVLP  08
....................                 DS_Print_Clock_3by(u8Alarm,1); 
0B0C:  MOVLW  20
0B0D:  MOVLB  01
0B0E:  MOVWF  3C
0B0F:  MOVLW  19
0B10:  MOVWF  3B
0B11:  MOVLW  01
0B12:  MOVWF  3D
0B13:  MOVLP  00
0B14:  MOVLB  00
0B15:  CALL   401
0B16:  MOVLP  08
....................                 u16ByteFlags &= ~SetAlarmFlagMask; 
0B17:  BCF    4B.4
0B18:  CLRF   4C
....................             } 
....................  
....................             if( ReadeClockFlagMask == ( u16ByteFlags & ReadeClockFlagMask ) ) 
0B19:  MOVF   4B,W
0B1A:  ANDLW  80
0B1B:  MOVWF  77
0B1C:  CLRF   7A
0B1D:  MOVF   77,W
0B1E:  SUBLW  80
0B1F:  BTFSS  03.2
0B20:  GOTO   36F
0B21:  MOVF   7A,F
0B22:  BTFSS  03.2
0B23:  GOTO   36F
....................             { 
....................                 putc(13);putc('R');putc('e');putc('a');putc('d');putc('e'); 
0B24:  MOVLW  0D
0B25:  MOVLP  00
0B26:  CALL   02D
0B27:  MOVLP  08
0B28:  MOVLW  52
0B29:  MOVLP  00
0B2A:  CALL   02D
0B2B:  MOVLP  08
0B2C:  MOVLW  65
0B2D:  MOVLP  00
0B2E:  CALL   02D
0B2F:  MOVLP  08
0B30:  MOVLW  61
0B31:  MOVLP  00
0B32:  CALL   02D
0B33:  MOVLP  08
0B34:  MOVLW  64
0B35:  MOVLP  00
0B36:  CALL   02D
0B37:  MOVLP  08
0B38:  MOVLW  65
0B39:  MOVLP  00
0B3A:  CALL   02D
0B3B:  MOVLP  08
....................                 putc('C');putc('l');putc('o');putc('c');putc('k'); 
0B3C:  MOVLW  43
0B3D:  MOVLP  00
0B3E:  CALL   02D
0B3F:  MOVLP  08
0B40:  MOVLW  6C
0B41:  MOVLP  00
0B42:  CALL   02D
0B43:  MOVLP  08
0B44:  MOVLW  6F
0B45:  MOVLP  00
0B46:  CALL   02D
0B47:  MOVLP  08
0B48:  MOVLW  63
0B49:  MOVLP  00
0B4A:  CALL   02D
0B4B:  MOVLP  08
0B4C:  MOVLW  6B
0B4D:  MOVLP  00
0B4E:  CALL   02D
0B4F:  MOVLP  08
....................                 DS_Power_Pin = 1; 
0B50:  BSF    0E.5
....................                 Delay_ms(2); 
0B51:  MOVLW  02
0B52:  MOVLB  01
0B53:  MOVWF  32
0B54:  MOVLP  00
0B55:  MOVLB  00
0B56:  CALL   1F6
0B57:  MOVLP  08
....................                 DS_Read_Clock_3by(u8ClockL); 
0B58:  MOVLW  20
0B59:  MOVLB  01
0B5A:  MOVWF  2C
0B5B:  MOVLW  54
0B5C:  MOVWF  2B
0B5D:  MOVLP  00
0B5E:  MOVLB  00
0B5F:  CALL   760
0B60:  MOVLP  08
....................                 DS_Power_Pin = 0; 
0B61:  BCF    0E.5
....................                  
....................                 DS_Print_Clock_3by(u8ClockL,1);   
0B62:  MOVLW  20
0B63:  MOVLB  01
0B64:  MOVWF  3C
0B65:  MOVLW  54
0B66:  MOVWF  3B
0B67:  MOVLW  01
0B68:  MOVWF  3D
0B69:  MOVLP  00
0B6A:  MOVLB  00
0B6B:  CALL   401
0B6C:  MOVLP  08
....................                 u16ByteFlags &= ~ReadeClockFlagMask; 
0B6D:  BCF    4B.7
0B6E:  CLRF   4C
....................             } 
....................                      
....................             if( SetClockFlagMask == ( u16ByteFlags & SetClockFlagMask ) ) 
0B6F:  MOVF   4B,W
0B70:  ANDLW  20
0B71:  MOVWF  77
0B72:  CLRF   7A
0B73:  MOVF   77,W
0B74:  SUBLW  20
0B75:  BTFSS  03.2
0B76:  GOTO   3D5
0B77:  MOVF   7A,F
0B78:  BTFSS  03.2
0B79:  GOTO   3D5
....................             { 
....................                 if((':' == cMsgClock[5]) && (':' == cMsgClock[2])) 
0B7A:  MOVF   5C,W
0B7B:  SUBLW  3A
0B7C:  BTFSS  03.2
0B7D:  GOTO   3D3
0B7E:  MOVF   59,W
0B7F:  SUBLW  3A
0B80:  BTFSS  03.2
0B81:  GOTO   3D3
....................                 { 
....................                     putc(13);putc('C');putc('l');putc('o');putc('c');putc('k'); 
0B82:  MOVLW  0D
0B83:  MOVLP  00
0B84:  CALL   02D
0B85:  MOVLP  08
0B86:  MOVLW  43
0B87:  MOVLP  00
0B88:  CALL   02D
0B89:  MOVLP  08
0B8A:  MOVLW  6C
0B8B:  MOVLP  00
0B8C:  CALL   02D
0B8D:  MOVLP  08
0B8E:  MOVLW  6F
0B8F:  MOVLP  00
0B90:  CALL   02D
0B91:  MOVLP  08
0B92:  MOVLW  63
0B93:  MOVLP  00
0B94:  CALL   02D
0B95:  MOVLP  08
0B96:  MOVLW  6B
0B97:  MOVLP  00
0B98:  CALL   02D
0B99:  MOVLP  08
....................                              putc('S');putc('e');putc('t'); 
0B9A:  MOVLW  53
0B9B:  MOVLP  00
0B9C:  CALL   02D
0B9D:  MOVLP  08
0B9E:  MOVLW  65
0B9F:  MOVLP  00
0BA0:  CALL   02D
0BA1:  MOVLP  08
0BA2:  MOVLW  74
0BA3:  MOVLP  00
0BA4:  CALL   02D
0BA5:  MOVLP  08
....................                     IOCIE = 0;// Interrupt-on-Change Enable bit 
0BA6:  BCF    0B.3
....................                     DS_Power_Pin = 1; 
0BA7:  BSF    0E.5
....................                      
....................                     Delay_ms(2); 
0BA8:  MOVLW  02
0BA9:  MOVLB  01
0BAA:  MOVWF  32
0BAB:  MOVLP  00
0BAC:  MOVLB  00
0BAD:  CALL   1F6
0BAE:  MOVLP  08
....................                     DecodeInitPrintClock_3by(cMsgClock); 
0BAF:  MOVLW  20
0BB0:  MOVLB  01
0BB1:  MOVWF  2C
0BB2:  MOVLW  37
0BB3:  MOVWF  2B
0BB4:  MOVLB  00
0BB5:  GOTO   000
....................                      
....................                     Delay_ms(200); 
0BB6:  MOVLW  C8
0BB7:  MOVLB  01
0BB8:  MOVWF  32
0BB9:  MOVLP  00
0BBA:  MOVLB  00
0BBB:  CALL   1F6
0BBC:  MOVLP  08
....................                     DS_Read_Clock_3by(u8ClockL); 
0BBD:  MOVLW  20
0BBE:  MOVLB  01
0BBF:  MOVWF  2C
0BC0:  MOVLW  54
0BC1:  MOVWF  2B
0BC2:  MOVLP  00
0BC3:  MOVLB  00
0BC4:  CALL   760
0BC5:  MOVLP  08
....................                      
....................                     DS_Power_Pin = 0; 
0BC6:  BCF    0E.5
....................                      
....................                     DS_Print_Clock_3by(u8ClockL,1); 
0BC7:  MOVLW  20
0BC8:  MOVLB  01
0BC9:  MOVWF  3C
0BCA:  MOVLW  54
0BCB:  MOVWF  3B
0BCC:  MOVLW  01
0BCD:  MOVWF  3D
0BCE:  MOVLP  00
0BCF:  MOVLB  00
0BD0:  CALL   401
0BD1:  MOVLP  08
....................                      
....................                     IOCIE = 1;// Interrupt-on-Change Enable bit 
0BD2:  BSF    0B.3
....................                 }                 
....................                 u16ByteFlags &= ~SetClockFlagMask; 
0BD3:  BCF    4B.5
0BD4:  CLRF   4C
....................             } 
....................             if( OneSecondTaskFlagMask == ( u16ByteFlags & OneSecondTaskFlagMask ) ) 
0BD5:  MOVF   4B,W
0BD6:  ANDLW  40
0BD7:  MOVWF  77
0BD8:  CLRF   7A
0BD9:  MOVF   77,W
0BDA:  SUBLW  40
0BDB:  BTFSS  03.2
0BDC:  GOTO   424
0BDD:  MOVF   7A,F
0BDE:  BTFSS  03.2
0BDF:  GOTO   424
....................             { 
.................... //                putc(13);putc('D');putc('S');putc('_');putc('T');putc('a');putc('s');putc('k'); 
....................                 if( SleepFlagMask == ( u8StaicByteFlags & SleepFlagMask ) ) 
0BE0:  MOVF   4F,W
0BE1:  ANDLW  02
0BE2:  SUBLW  02
0BE3:  BTFSS  03.2
0BE4:  GOTO   41E
....................                 { 
....................                     DS_Power_Pin = 1; 
0BE5:  BSF    0E.5
....................                     Delay_ms(2); 
0BE6:  MOVLW  02
0BE7:  MOVLB  01
0BE8:  MOVWF  32
0BE9:  MOVLP  00
0BEA:  MOVLB  00
0BEB:  CALL   1F6
0BEC:  MOVLP  08
....................                     DS_Task(); 
0BED:  CALL   0C1
....................                      
....................                     if( SleepDelayFlagMask == ( u16ByteFlags2 & SleepDelayFlagMask) ) 
0BEE:  MOVF   4D,W
0BEF:  ANDLW  01
0BF0:  MOVWF  77
0BF1:  CLRF   7A
0BF2:  MOVF   77,W
0BF3:  SUBLW  01
0BF4:  BTFSS  03.2
0BF5:  GOTO   406
0BF6:  MOVF   7A,F
0BF7:  BTFSS  03.2
0BF8:  GOTO   406
....................                     { 
....................                         u8SleepCountL++; 
0BF9:  MOVLB  01
0BFA:  INCF   23,F
....................                         if(5 < u8SleepCountL) 
0BFB:  MOVF   23,W
0BFC:  SUBLW  05
0BFD:  BTFSC  03.0
0BFE:  GOTO   404
....................                         { 
....................                             u16ByteFlags2 &= ~SleepDelayFlagMask; 
0BFF:  MOVLB  00
0C00:  BCF    4D.0
0C01:  CLRF   4E
....................                             u8SleepCountL = 0; 
0C02:  MOVLB  01
0C03:  CLRF   23
....................                         } 
....................                     } 
0C04:  GOTO   41C
0C05:  MOVLB  00
....................                     else 
....................                     { 
....................                         Delay_ms(2); 
0C06:  MOVLW  02
0C07:  MOVLB  01
0C08:  MOVWF  32
0C09:  MOVLP  00
0C0A:  MOVLB  00
0C0B:  CALL   1F6
0C0C:  MOVLP  08
.................... //                        TBD 2 ms? 
....................                         DS_Power_Pin = 0; 
0C0D:  BCF    0E.5
....................                         StartWakeUpFromUART(); 
0C0E:  MOVLP  00
0C0F:  CALL   20C
0C10:  MOVLP  08
....................                         u16ByteFlags &= ~OneSecondTaskFlagMask; 
0C11:  BCF    4B.6
0C12:  CLRF   4C
.................... //                        putc(13);putc('S');putc('l');putc('e');putc('e');putc('p'); 
....................                         Delay_ms(2); 
0C13:  MOVLW  02
0C14:  MOVLB  01
0C15:  MOVWF  32
0C16:  MOVLP  00
0C17:  MOVLB  00
0C18:  CALL   1F6
0C19:  MOVLP  08
....................                         SLEEP(); 
0C1A:  SLEEP
0C1B:  MOVLB  01
....................                     } 
....................                 } 
0C1C:  GOTO   421
0C1D:  MOVLB  00
....................                 else 
....................                 { 
....................                     DS_Power_Pin = 1; 
0C1E:  BSF    0E.5
....................                     DS_Task(); 
0C1F:  CALL   0C1
0C20:  MOVLB  01
....................                 } 
....................                 u16ByteFlags &= ~OneSecondTaskFlagMask; 
0C21:  MOVLB  00
0C22:  BCF    4B.6
0C23:  CLRF   4C
....................             } 
....................         } 
0C24:  GOTO   29F
....................     } 
.................... } 
0C25:  GOTO   425

Configuration Fuses:
   Word  1: 19A4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO NOFCMEN
   Word  2: 0633   NOWRT NOVCAP PLL_SW STVREN BORV19 DEBUG NOLVP

   Some fuses have been forced to be compatible with the ICD debugger.
